# 位运算

## 位运算

按位与：两位都为1，结果就为1

按位或：只要有一个1，结果就为1

按位异或：两位不同则为1，相同则为0

```go
func bitOperation() {
    fmt.Println(22 & 13)//4
    fmt.Println(22 | 13)//31
    fmt.Println(22 ^ 13)//27
}
```

## 移位运算

左移：末尾添0

右移：移除边界

```go
func shiftOperation() {
    //22类型为int，在64位机下实际为int64,

    //10110右移3位变成10,即结果为2
    fmt.Println(22 >> 3)
    //10110左移3位变成10110000,即结果为176
    fmt.Println(22 << 3)
}	
```

## 负数表示

使用补码：（源码）取反加1

以22为例：

源码 0001 0110

取反 1110 1001

加一 1110 1010

即-22就是 1110 1010

## 移位运算形成负数

整数值没有明确声明类型时，默认使用int，在64位机器下默认int64

int8的22，二进制为10110，左移3位1011 0000，实际上成为负数-80

```go
func shiftNegative() () {
    fmt.Printf("type=%T\n",22)

    //原码：0001,0110
    //左三：1011，0000，这是一个负数的补码，需要通过减一取反得到绝对值
    //减一：1010,1111
    //取反：0101,0000，为80
    //所以左三后实际表示-80
    var a int8 = 22
    fmt.Println(a<<3)
}
```

## 移位运算的溢出

左移达到类型允许的最高位，会overflow溢出，形成事实上的工程错误

int8的22，二进制为10110，左移4位1 0110 0000，高位溢出形成

溢出后有效位的值为96，而它没有实际意义

```go
func shiftOverflow() () {
    var a int8 = 22

    //左移4位后：1,0110,0000
    //忽略溢出后：0110,0000，即96
    //而事实上这已经是一个工程错误了
    fmt.Println(a<<4)
}
```



