# 封装

## 面向对象概述

- 在没有面向对象的年代，编程的方式是面向过程的
- 面向过程的编程，管理的是一个一个的函数，撸工程就是堆砌大量的函数
- 面向对象中类的概念，Go语言是通过结构体来实现的
- 类/结构体是对函数的进一步封装，即把有机关联的变量和函数封装为一个结构体
- 有了类/结构体的概念以后，撸工程就由管理大量的函数变为了管理少量的类
- 书本理论中面向函数的三大特性是：封装、继承、多态（有时会再加一个抽象）
- 继承性实现了低成本地扩展原有代码
- 多态性实现了大规模代码的组装和调度
- 面向对象使工程开发变成了搭建框架和组装模块的游戏
- 面向对象的出现使大规模协作与大规模开发变得更容易了

## 封装性概述

- 封装就是将业务逻辑相近的变量和函数封装在一起，成为一个结构体
- 被封起来的变量称之为属性
- 被封起来的函数称之为方法
- 封装的意义，在于整理和简化代码结构
- 封装也是继承和多态的基础

## 封装结构体

```go
//定义结构体
type Dog struct {
    //定义狗的属性
    name string
    sex int
}

/*封装狗的方法*/
//setter
func (d *Dog)SetName(name string)  {
    //在这里可以加一些权限校验
    d.name = name
}

//getter
func (d *Dog)GetName() string {
    //在这里可以加一些权限校验
    return d.name
}

//定义咬人方法
func (d *Dog)bite()  {
    fmt.Printf("让本汪%s来给你一些震撼教育...",d.name)
}
```

### 创建空白对象并给属性赋值

```go
func demo21() {
    //创建空白对象
    d := Dog{}

    //给对象的属性赋值
    d.name = "臭皮"
    d.sex = 1
    fmt.Println(d.sex)
    d.bite()
}
```

### 创建对象的同时有序而完整的给属性赋值

```go
func demo22() {
    //创建对象的同时有序而完整地给属性赋值
    d := Dog{"臭皮", 1}
    fmt.Println(d.sex)
    d.bite()
}
```

### 创建对象并有选择的给属性赋值

```go
func demo23() {
    d := Dog{name: "臭皮"}
    d.sex = 1
    d.SetName("旺财")
    fmt.Println(d.GetName())
    d.bite()
}
```

###  **创建空白指针对象并给属性赋值** 

```go
func demo24() {
    dp := new(Dog)

    //通过【指针】访问结构体的【成员】（包括属性和方法）和通过【值】访问一模一样
    dp.SetName("臭皮")
    dp.bite()
}
```

### 使用工厂模式创建对象

- 封装【创建实例的重复复杂过程】为固定的套路和【模式】
- 以后就可以【反反复复】、【轻松加愉快】地复用模式和套路了
- 正所谓【自古真情没卵用，唯有套路得人心】，阿门
- 这个一次封装、反复玩弄的套路，就称为【工厂模式】
- 工厂模式——将造实例这件事情做专业化的封装，并反复调用

```go
//工厂方法
func NewDog(name string,sex int) *Dog  {
    d := new(Dog)
    d.name = name
    d.sex = sex
    return d
}

//使用工厂模式创建对象
func demo25() {
    xiaohei := NewDog("小黑", 1)
    xiaohei.bite()
}
```

