{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction powered by Gitbook修订时间： 2020-04-28 10:08:07 "},"01Go/Go语言介绍.html":{"url":"01Go/Go语言介绍.html","title":"Go简介","keywords":"","body":"Go语言介绍 Go特征 简单、可靠、高效 并发，有趣，开源 内存管理，数组安全，编译迅速 Go语言优势 拥有全局自动垃圾回收机制 拥有全局错误处理机制 支持丰富的类型和接口 支持百万级高并发 底层语言，权限直达系统底层 拥有丰富的内置类型 函数支持多个返回值 支持匿名函数和闭包函数 支持反射 Go核心思想 组合（composition） Go语言从C和C++简化的功能 规范的语法（不需要符号表来解析） 垃圾回收（独有） 无头文件 明确的依赖 无循环依赖 常量只能是数字 int和int32是两种类型 字母大小写设置可见性（letter case sets visibility） 任何类型（type）都有方法（不是类型） 没有子类型继承（不是子类） 包级别初始化以及明确的初始化顺序 文件被编译到一个包里 包package-level globals presented in any order 没有数值类型转换（常量起辅助作用） 接口隐式实现（没有“implement”声明） 嵌入（不会提升到超类） 方法按照函数声明（没有特别的位置要求） 方法即函数 接口只有方法（没有数据） 方法通过名字匹配（而非类型） 没有构造函数和析构函数 postincrement（如++i）是状态，不是表达式 没有preincrement(i++)和predecrement 赋值不是表达式 明确赋值和函数调用中的计算顺序（没有“sequence point”） 没有指针运算 内存一直以零值初始化 局部变量取值合法 方法中没有“this” 分段的堆栈 没有静态和其它类型的注释 没有模板 没有异常 内建string、slice和map 数组边界检查 Go语言设计 Go语言一个重要的安全设计就是禁止隐式的类型转换 powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"01Go/Go语言开发环境搭建.html":{"url":"01Go/Go语言开发环境搭建.html","title":"Go语言开发环境","keywords":"","body":"Go语言开发环境 开发环境搭建 下载地址 Go编译器 https://golang.google.cn/dl/ Goland官网下载 https://www.jetbrains.com/go/download/#section=windows 在线激活地址 http://idea.youbbs.org 配置环境变量 Go 语言依赖一个重要的环境变量：$GOPATH GOPATH允许多个目录，当有多个目录时，请注意分隔符，多个目录的时候Windows是分号，Linux系统是冒号，当有多个GOPATH时，默认会将go get的内容放在第一个目录下。 $GOPATH 目录约定有三个子目录： src 存放源代码（比如：.go .c .h .s等） pkg 编译后生成的文件（比如：.a） bin 编译后生成的可执行文件（为了方便，可以把此目录加入到 $PATH 变量中） 查看变量是否设置成功 ： go env powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"01Go/GOPATH.html":{"url":"01Go/GOPATH.html","title":"GOPATH","keywords":"","body":"GOPATH File->Settings->Go->GOPATH 作用 存放SDK以外的第三方类库 可以是下载的第三方类库 也可以是自己收藏的可复用代码 目录结构 GOPATH目录可以指定多个 每一个GOPATH目录下必须有一个src目录 src目录下的文件夹名称就是引用时的包名 eg: import fuck.shit shit.EatSome(5) 上述实例成功运行的前提 GOPATH目录之一下存在路径：src/fuck/shit/ shit目录下的某个go源文件中有函数定义：func EatSome(kg int) 全局GOPATH 所有工程可用 全局GOPATH目录也可以以GOPATH环境变量的方式配置 工程GOPATH 只有当前工程可用 powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/数据类型.html":{"url":"02GoBase/数据类型.html","title":"数据类型","keywords":"","body":"数据类型 布尔型 var b bool = true/false true对应1 false对应0 数值型 整型 uint8:无符号 8 位整型 (0 到 255) uint16:无符号 16 位整型 (0 到 65535) uint32:无符号 32 位整型 (0 到 4294967295) uint64:无符号 64 位整型 (0 到 18446744073709551615) int8:有符号 8 位整型 (-128 到 127) int16:有符号 16 位整型 (-32768 到 32767) int32:有符号 32 位整型 (-2147483648 到 2147483647) int64:有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) byte: 类似uint8：1位，常用于ASCII码,AmericanStandardCodeForInformationInterchange美国标准信息交换码,128个最基本的字符, 大小写字母, 阿拉伯数字, 英文标点符号,常用的其他符号。 rune类似 int32:4位 uint: 32 或 64 位 int与 uint 一样大小 uintptr:无符号整型，用于存放一个指针 浮点型 float32 float64 复数 var mc complex64 = 3+4i complex64:32 位实数和虚数 complex128: 64 位实数和虚数 字符串型 string类型使用双引号\"\"或者反引号``引起来的字符串变量，采用UTF-8编码 双引号用来创建 可解析的字符串字面量 (支持转义，但不能用来引用多行)； 反引号用来创建 原生的字符串字面量 ，这些字符串可能由多行组成(不支持任何转义序列)，原生的字符串字面量多用于书写多行消息、HTML以及正则表达式。 字符集 ASCII AmericanStandardCodeForInformationInterchange 美国标准信息交换码 128个最基本的字符 大小写字母 阿拉伯数字 英文标点符号 常用的其他符号 一个ASCII字符占1字节 码表 Unicode 1个Unicode字符占2字节 包含常用的主要语种的主要字符 UTF-8 比Unicode包含的字符更多，几乎包含了全部的人类文明字符 汉字占3个字节，个别占4个字节 GBK 中文专用字符集 汉字占2个字节 var name string = \"张全蛋\" 错误类型 error 说明 a.不同类型，不同长度之间不允许相互转换，不能相互赋值。 b.字符串类型变量值是不可修改的。不能修改里面的字符。 c.根据平台确定，32位系统\"int\"和\"int32\"属于同一种类型，但是byte 和int8是同一种类型 整数字面 十进制数字面 = { 十进制数字 } . 八进制数字面 = \"0\" + { 八进制数字 } . 十六进制数字面 = \"0\" + ( \"x\" | \"X\" ) + { 十六进制数字 } . 浮点数字面 = 十进制数 \".\" [ 十进制数 ] [ 指数E ] | 十进制指数E | \".\" 十进制数 [ 指数E ] . 十进制数 = 十进制数字 { 十进制数字 } . 指数E = ( \"e\" | \"E\" ) [ \"+\" | \"-\" ] 十进制数 . powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/常量、变量、表达式.html":{"url":"02GoBase/常量、变量、表达式.html","title":"常量、变量、表达式","keywords":"","body":"常量、变量、表达式 常量的申明 const 常量名 变量类型 = 变量值 const 常量名 = 变量值 （省略类型） //圆周率是永恒不变的 const pi float32 = 3.14 变量的申明 定义变量 //如果定义变量，没有赋值的话，编译时候会自动赋初始值 var 变量名 变量类型 //半径是实时变化的 var radius int 定义变量并赋初值 //定义变量并赋初值 var 变量名 变量类型 = 变量值 var 变量名 = 变量值 变量名:=变量值 var x int = 1 var x,y = 1,2 x,y:=1,2 多变量声明或定义 var x,y,z int //声明类型相同变量 var( //声明类型不同变量 x int y float z bool ) var x,y = 1,1.3 //变量赋值 x,y := 1,1.3 //变量赋值 表达式 将常量变量使用运算符连接起来的式子 //面积计算的表达式 var area=pi*radius*radius 动态检测常量和变量的类型 //动态判别类型 const LightSpeed = 300000 var isClever = false func main() { //int fmt.Println(\"常量LightSpeed的实际类型是%T\\n\",LightSpeed) //bool fmt.Println(\"变量isClever的实际类型是%T\\n\",isClever) } 一次性声明多个常量或变量 //一次性声明多个 const( Chidao = 40000 ChinaArea int = 960 ) var( fug = \"hello\" shid int = 123 ) 在函数内，可以将变量的声明和赋值合二为一 func main() { //变量的声明赋值合二为一，这种声明方式只能在函数内部 dann := 456.78 fmt.Printf(\"type=%T,value=%v\\n\",dann,dann) } 更多变量申明的例子 //声明布尔型变量 //var isStupid bool = true//真 //var isStupid bool = false//假 var isStupid bool /*声明数值型变量*/ //var age int = 60 var age int //var rmb float32 = 0.5 var rmb float32 //复数 //var vector complex64 = 3+4i var vector complex64 //声明字符串变量 //var name string = \"张全蛋\" var name string /*声明复合型变量*/ //10长度的整型数组 //var ages [10]int = [10]int{1,2,3,4,5,6,7,8,9,0} var ages [10]int //可变长的整型切片 //var heights []int = []int{1,2,3} var heights []int //映射（键1：值1，键2：值2...） //var kpi map[string]int = map[string]int{\"代码量\":10000,\"注释量\":3000} var kpi map[string]int var weight int = 300 //整型指针，weightPointer存放的不是300，而是放置300的内存地址 //var weightPointer *int = &weight var weightPointer *int //定义公有的（首字母大写，否则包内私有）接口Animal //Go语言是强类型语言，但是空接口interface{}可以代指任何类型 var Animal interface{} //结构体 //var person struct { // name string // age int // rmb float32 //} var person struct{} //声明函数变量 //var eat func() = func() { // fmt.Println(\"我是个吃货\") //} var eat func(a int,b float64)bool func main() { /* fmt.Printf格式化打印 %T 类型占位符 %v 值占位符 */ fmt.Printf(\"【是否愚蠢】的类型是%T，值是%v\\n\",isStupid,isStupid) fmt.Printf(\"【年龄】的类型是%T，值是%v\\n\",age,age) fmt.Printf(\"【资产】的类型是%T，值是%v\\n\",rmb,rmb) fmt.Printf(\"【向量】的类型是%T，值是%v\\n\",vector,vector) fmt.Printf(\"【姓名】的类型是%T，值是%v\\n\",name,name) fmt.Printf(\"【年龄们】的类型是%T，值是%v\\n\",ages,ages) fmt.Printf(\"【身高们】的类型是%T，值是%v\\n\",heights,heights) fmt.Printf(\"【KPI】的类型是%T，值是%v\\n\", kpi, kpi) fmt.Printf(\"【存体重的地址】的类型是%T，值是%v\\n\",weightPointer,weightPointer) fmt.Printf(\"【人】的类型是%T，值是%v\\n\", person, person) fmt.Printf(\"【饕餮】的类型是%T，值是%v\\n\",eat,eat) } 类型转换 1）不支持隐式转换。go语言不会对不同类型变量做任何隐式转换。 2) 只支持少数几种类型的强制转换。 允许的转换 1）string转为字节，string转为int slice []byte(str) 可以将字符串类型转为字节类型 []int(str) 可以将字符串类型转为int slice类型 2)字节转为string string(b) 可以将字节类型转为字符串类型 3）int slice转为string string(intslice) 可以将int slice类型转为字符串类型 4)整数互转 unit8(intx) 5)整数，浮点互转 int(floatx) //会截断小数字部分 float(intx) 6)自定义转为 如果2个类型有相同字段。尝试可以互相转换。 powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/iota定义常量组.html":{"url":"02GoBase/iota定义常量组.html","title":"iota定义常量组","keywords":"","body":"iota定义常量组 概述 第一个常量的iota，值为0 后面的常量自动沿用第一个常量的表达式 后面常量中的iota会自动递增 package main import \"fmt\" //常量组中的iota会从0开始自动增长 const ( Sunday = iota //0 Monday Tuesday Wednesday Thursday Friday Saturday ) //常量组中的iota会从0开始自动增长 /*const ( D = 1 powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/输入输出用例.html":{"url":"02GoBase/输入输出用例.html","title":"输入输出用例","keywords":"","body":"输入输出用例 标准输入输出 import ( \"fmt\" \"math/rand\" \"time\" ) func main() { fmt.Println(\"亲请输入下注金额和下注球队:\") var money int var team string fmt.Scanf(\"%d+%s\", &money, &team) fmt.Printf(\"您下注了%s%d万元，人生巅峰即将开始...\\n\",team,money) time.Sleep(1 * time.Second) //time.Now().Unix()获取当前时间距离1970年零时逝去的秒数 //rand.NewSource(time.Now().Unix())每秒更新一个随机数的种子,一旦种子变化随机数也随之变化 myrand := rand.New(rand.NewSource(time.Now().Unix())) //获得[0-100)的随机数 luckyNumber := myrand.Intn(100) fmt.Println(\"luckyNumber=\", luckyNumber) if luckyNumber > 10 { fmt.Println(\"靠海别野欢迎你\") } else { fmt.Println(\"天台欢迎你\") } } 格式化打印 func main() { type cat struct{ name string lives int } c := cat{\"Coding喵\",1} /* ·几乎所有占位符都可以前置宽度和左右对齐：10%s代表10宽度右对齐，-10%s代表10宽度左对齐 ·输出中带有小数位的，都可以指定其精度：.2%e */ //通用占位符 fmt.Println(\"-----通用占位符-----\") fmt.Printf(\"%v\\n\",c)//{Coding喵 1} fmt.Printf(\"%+v\\n\",c)//{name:Coding喵 lives:1} fmt.Printf(\"%#v\\n\",c)//main.cat{name:\"Coding喵\", lives:1} fmt.Printf(\"%T\\n\",c)//main.cat fmt.Printf(\"%f%%\\n\",12.34)//12.340000% //基本类型占位符 fmt.Println(\"-----基本类型占位符-----\") fmt.Printf(\"%d\\n\",123)//123，整型(decimal) fmt.Printf(\"%f\\n\",123.45)//123.450000，浮点型(float) fmt.Printf(\"%t\\n\",false)//false，布尔类型(true) fmt.Printf(\"%s\\n\",\"hello\")//hello，字符串类型(string) fmt.Printf(\"%q\\n\",\"hello\")//\"hello\"，带引号字符串类型(quotation) fmt.Printf(\"%p\\n\",&c)//0xc04205c3e0，指针类型(pointer) //进制占位符 fmt.Println(\"-----进制占位符-----\") fmt.Printf(\"%b\\n\",123)//1111011，二进制(binary) fmt.Printf(\"%o\\n\",123)//173，八进制进制(octal) fmt.Printf(\"%d\\n\",123)//123，十进制(decimal) fmt.Printf(\"%x\\n\",123)//7b，十六进制小写(hex) fmt.Printf(\"%X\\n\",123)//7B，十进制大写(hex) //科学计数法 fmt.Println(\"-----科学计数法-----\") fmt.Printf(\"%e\\n\",123456789012345.0)//1.234568e+14 fmt.Printf(\"%e\\n\",0.00000000012345)//1.234500e-10 fmt.Printf(\"%E\\n\",123456789012345.0)//1.234568E+14 fmt.Printf(\"%E\\n\",0.00000000012345)//1.234500E-10 fmt.Printf(\"%g\\n\",12345.0)//12345 智能选择【常规浮点数】或【科学计数法】显示 fmt.Printf(\"%g\\n\",123456789012345.0)//1.23456789012345e+14 fmt.Printf(\"%G\\n\",12345.0)//12345 fmt.Printf(\"%G\\n\",0.0000000012345)//1.2345E-09 //字符集占位符 fmt.Println(\"-----科学计数法-----\") fmt.Printf(\"%c\\n\",123)//{ Unicode字符的【字符形式】 fmt.Printf(\"%U\\n\",123)//U+007B Unicode字符的【十六进制序号形式】 fmt.Printf(\"%c\\n\",'{')//{ Unicode字符的【字符形式】 fmt.Printf(\"%U\\n\",'{')//U+007B Unicode字符的【字符形式】 //设置输出的宽度和对齐方式 fmt.Println(\"-----宽度和对齐-----\") fmt.Printf(\"%20v\\n\",c) fmt.Printf(\"%20d\\n\",123) fmt.Printf(\"%20b\\n\",123) fmt.Printf(\"%20e\\n\",123456789012345.0) fmt.Printf(\"%20c\\n\",123) fmt.Printf(\"%-20v\\n\",c) fmt.Printf(\"%-20d\\n\",123) fmt.Printf(\"%-20b\\n\",123) fmt.Printf(\"%-20e\\n\",123456789012345.0) fmt.Printf(\"%-20c\\n\",123) //设置输出的小数精度 fmt.Println(\"-----小数精度-----\") fmt.Printf(\"%.2f%%\\n\",12.34)//12.340000% fmt.Printf(\"%.2f\\n\",123.45) fmt.Printf(\"%.2e\\n\",123456789012345.0)//1.234568e+14 fmt.Printf(\"%.2e\\n\",0.00000000012345)//1.234500e-10 fmt.Printf(\"%.2E\\n\",123456789012345.0)//1.234568E+14 fmt.Printf(\"%.2E\\n\",0.00000000012345)//1.234500E-10 //g/G的精度代表数字的总位数 fmt.Printf(\"%.3g\\n\",12345.0)//12345 智能选择【常规浮点数】或【科学计数法】显示 fmt.Printf(\"%.3g\\n\",123456789012345.0)//1.23456789012345e+14 fmt.Printf(\"%.3G\\n\",12345.0)//12345 fmt.Printf(\"%.3G\\n\",0.0000000012345)//1.2345E-09 } fmt的spring系列函数将预期输出转换为字符串 func main() { //打印：造一个字符串，并输出到控制台 /* fmt.Print(\"abc\") fmt.Println(\"abc\") fmt.Printf(\"abc%d\\n\",123)*/ //sprint：造一个字符串，返回之 //fmt.Print(123, 456.78, \"你妹\", [3]int{6, 6, 6}) mstr := fmt.Sprint(123, 456.78, \"你妹\", [3]int{6, 6, 6}) //结果尾部包含一个\\n mstr = fmt.Sprintln(\"abc\") mstr = fmt.Sprintf(\"当一只猪拥有%.2e%s时，它就不再是一只猪，而是%s\\n\",1234567890.0,\"BTC\",\"大帅比\") fmt.Print(mstr) } powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/结构化输出.html":{"url":"02GoBase/结构化输出.html","title":"结构化输出","keywords":"","body":"结构化输出 package main import ( \"fmt\" \"os\" ) type point struct { x, y int } func main() { // Go提供了几种打印格式，用来格式化一般的Go值，例如 // 下面的%v打印了一个point结构体的对象的值 p := point{1, 2} fmt.Printf(\"%v\\n\", p) // 如果所格式化的值是一个结构体对象，那么`%+v`的格式化输出 // 将包括结构体的成员名称和值 fmt.Printf(\"%+v\\n\", p) // `%#v`格式化输出将输出一个值的Go语法表示方式。 fmt.Printf(\"%#v\\n\", p) // 使用`%T`来输出一个值的数据类型 fmt.Printf(\"%T\\n\", p) // 格式化布尔型变量 fmt.Printf(\"%t\\n\", true) // 有很多的方式可以格式化整型，使用`%d`是一种 // 标准的以10进制来输出整型的方式 fmt.Printf(\"%d\\n\", 123) // 这种方式输出整型的二进制表示方式 fmt.Printf(\"%b\\n\", 14) // 这里打印出该整型数值所对应的字符 fmt.Printf(\"%c\\n\", 33) // 使用`%x`输出一个值的16进制表示方式 fmt.Printf(\"%x\\n\", 456) // 浮点型数值也有几种格式化方法。最基本的一种是`%f` fmt.Printf(\"%f\\n\", 78.9) // `%e`和`%E`使用科学计数法来输出整型 fmt.Printf(\"%e\\n\", 123400000.0) fmt.Printf(\"%E\\n\", 123400000.0) // 使用`%s`输出基本的字符串 fmt.Printf(\"%s\\n\", \"\\\"string\\\"\") // 输出像Go源码中那样带双引号的字符串，需使用`%q` fmt.Printf(\"%q\\n\", \"\\\"string\\\"\") // `%x`以16进制输出字符串，每个字符串的字节用两个字符输出 fmt.Printf(\"%x\\n\", \"hex this\") // 使用`%p`输出一个指针的值 fmt.Printf(\"%p\\n\", &p) // 当输出数字的时候，经常需要去控制输出的宽度和精度。 // 可以使用一个位于%后面的数字来控制输出的宽度，默认 // 情况下输出是右对齐的，左边加上空格 fmt.Printf(\"|%6d|%6d|\\n\", 12, 345) // 你也可以指定浮点数的输出宽度，同时你还可以指定浮点数的输出精度 fmt.Printf(\"|%6.2f|%6.2f|\\n\", 1.2, 3.45) // To left-justify, use the `-` flag. fmt.Printf(\"|%-6.2f|%-6.2f|\\n\", 1.2, 3.45) // 你也可以指定输出字符串的宽度来保证它们输出对齐。默认情况下，输出是右对齐的 fmt.Printf(\"|%6s|%6s|\\n\", \"foo\", \"b\") // 为了使用左对齐你可以在宽度之前加上`-`号 fmt.Printf(\"|%-6s|%-6s|\\n\", \"foo\", \"b\") // `Printf`函数的输出是输出到命令行`os.Stdout`的，你 // 可以用`Sprintf`来将格式化后的字符串赋值给一个变量 s := fmt.Sprintf(\"a %s\", \"string\") fmt.Println(s) // 你也可以使用`Fprintf`来将格式化后的值输出到`io.Writers` fmt.Fprintf(os.Stderr, \"an %s\\n\", \"error\") } //输出显示 {1 2} {x:1 y:2} main.point{x:1, y:2} main.point true 1110 ! 1c8 78.900000 1.234000e+08 1.234000E+08 \"string\" \"\\\"string\\\"\" 0xc042052070 | 12| 345| | 1.20| 3.45| |1.20 |3.45 | | foo| b| |foo |b | a string an error powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/程序运算1-数学运算.html":{"url":"02GoBase/程序运算1-数学运算.html","title":"数学运算","keywords":"","body":"数学运算 package main import \"fmt\" func main() { demo61() } func demo61() { var ret float32 //ret = getResult(5, 3, \"+\") //fmt.Println(\"ret=\", ret) //ret = getResult(5, 3, \"-\") //fmt.Println(\"ret=\", ret) //ret = getResult(5, 3, \"*\") //fmt.Println(\"ret=\", ret) ret = getResult2(5, 3, \"/\") fmt.Println(\"ret=\", ret) ret = getResult2(5, 3, \"%\") fmt.Println(\"ret=\", ret) } //if-elseif-else结构 func getResult(a float32, b float32, operator string) (ret float32) { /* 单分支 if operator==\"+\"{ ret = a+b } */ /* //双分支 if operator==\"+\"{ ret = a+b }else { fmt.Printf(\"不支持的操作符：%s\\n\",operator) } */ //多分支 if operator == \"+\" { ret = a + b } else if operator == \"-\" { ret = a - b } else if operator == \"*\" { ret = a * b } else if operator == \"/\" { ret = a / b } else if operator == \"%\" { ret = float32(int(a) % int(b)) } else { fmt.Printf(\"不支持的操作符：%s\\n\", operator) } return } //switch-case-default结构 func getResult2(a float32, b float32, operator string) (ret float32) { //判断operator的取值 switch operator { //情形1,2,3... case \"+\": ret = a + b case \"-\": ret = a - b case \"*\": ret = a * b case \"/\": ret = a / b case \"%\": ret = float32(int(a) % int(b)) //如果不符合上述任何一种情形 default: fmt.Printf(\"不支持的操作符:%s\\n\", operator) } return } powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/程序运算2-逻辑运算.html":{"url":"02GoBase/程序运算2-逻辑运算.html","title":"逻辑运算","keywords":"","body":"逻辑运算 概述 逻辑运算结果true或false 运算符包括相等、与、或、非：==，&&，||，！ 条件与：同时为真就为真 条件或：只要有一个为真，结果就为真 条件非：对结果取反 func main() { //a1,b1为true // a0,b0为false var a1 = (5 > 3) var a0 = (5 powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/程序运算3-位运算.html":{"url":"02GoBase/程序运算3-位运算.html","title":"位运算","keywords":"","body":"位运算 位运算 按位与：两位都为1，结果就为1 按位或：只要有一个1，结果就为1 按位异或：两位不同则为1，相同则为0 func bitOperation() { fmt.Println(22 & 13)//4 fmt.Println(22 | 13)//31 fmt.Println(22 ^ 13)//27 } 移位运算 左移：末尾添0 右移：移除边界 func shiftOperation() { //22类型为int，在64位机下实际为int64, //10110右移3位变成10,即结果为2 fmt.Println(22 >> 3) //10110左移3位变成10110000,即结果为176 fmt.Println(22 负数表示 使用补码：（源码）取反加1 以22为例： 源码 0001 0110 取反 1110 1001 加一 1110 1010 即-22就是 1110 1010 移位运算形成负数 整数值没有明确声明类型时，默认使用int，在64位机器下默认int64 int8的22，二进制为10110，左移3位1011 0000，实际上成为负数-80 func shiftNegative() () { fmt.Printf(\"type=%T\\n\",22) //原码：0001,0110 //左三：1011，0000，这是一个负数的补码，需要通过减一取反得到绝对值 //减一：1010,1111 //取反：0101,0000，为80 //所以左三后实际表示-80 var a int8 = 22 fmt.Println(a 移位运算的溢出 左移达到类型允许的最高位，会overflow溢出，形成事实上的工程错误 int8的22，二进制为10110，左移4位1 0110 0000，高位溢出形成 溢出后有效位的值为96，而它没有实际意义 func shiftOverflow() () { var a int8 = 22 //左移4位后：1,0110,0000 //忽略溢出后：0110,0000，即96 //而事实上这已经是一个工程错误了 fmt.Println(a powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/流程控制1-选择结构.html":{"url":"02GoBase/流程控制1-选择结构.html","title":"选择结构","keywords":"","body":"选择结构 if-else结构 条件语句通过制定一个或者多个条件，并测试条件是否为true来决定是否执行指定语句，并在调教为false的情况下执行另外的语句 func getResult(a float32, b float32, operator string) (ret float32) { /* 单分支 if operator==\"+\"{ ret = a+b } */ /* //双分支 if operator==\"+\"{ ret = a+b }else { fmt.Printf(\"不支持的操作符：%s\\n\",operator) } */ //多分支 if operator == \"+\" { ret = a + b } else if operator == \"-\" { ret = a - b } else if operator == \"*\" { ret = a * b } else if operator == \"/\" { ret = a / b } else if operator == \"%\" { ret = float32(int(a) % int(b)) } else { fmt.Printf(\"不支持的操作符：%s\\n\", operator) } return } switch-case-default结构 switch语句用于基于不同条件执行不同动作，每一个case分支都是唯一的，从上至下逐一检测，直到匹配为止，匹配项后面与不需要再加break func getResult2(a float32, b float32, operator string) (ret float32) { //判断operator的取值 switch operator { //情形1,2,3... case \"+\": ret = a + b case \"-\": ret = a - b case \"*\": ret = a * b case \"/\": ret = a / b case \"%\": ret = float32(int(a) % int(b)) //如果不符合上述任何一种情形 default: fmt.Printf(\"不支持的操作符:%s\\n\", operator) } return } powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/流程控制2-循环结构.html":{"url":"02GoBase/流程控制2-循环结构.html","title":"循环结构","keywords":"","body":"循环结构 概述 for init; condition; post { } 说明： init: 一般为赋值表达式，给控制变量赋初值 condition：关系表达式或逻辑表达式，循环控制条件 post：一般为复制表达式，给控制变量增量或者减量 for循环执行过程： 1，先对表达式1赋初值 2，判别复制表达式init是否满足给定条件，若其值为真值，满足循环条件，则执行循环体内语句，然后执行post，进入第二次循环，再判断condition；否则判断condition的值为假，不满足条件，就终止for循环，执行循环体外语句 无限死循环 func demo81() { //无限死循环 for { fmt.Println(\"爱天台，爱日耳曼战车\") time.Sleep(1 * time.Second) } } 有限次循环 func demo83() { //起始条件：i=1，循环条件：i 条件循环 func demo84() { for i := 1; i func demo85() { for i := 1; i continue略过本次循环 func main() { //循环100次，输出循环序号 //逢10跳过 for i := 1; i powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/流程控制3-延时执行defer.html":{"url":"02GoBase/流程控制3-延时执行defer.html","title":"延时执行defer","keywords":"","body":"延时执行defer defer概述 defer XXX() 延时执行，将xxx放在函数的最后执行 多个defer xxx()时，所有defer倒序执行，即最在声明的defer会最后执行 用途 IO(数据库读写，文件读写，网络数据读写) IO资源=数据库连接，打开的文件对象，网路连接 IO资源开销（CPU，内存，磁盘…）巨大 IO资源，随用随开，用完【即】关 场景 IO只是场景之一 其它场景：消费完毕要买单，运动完要洗澡，自习结束要关灯… 读写数据库，并在程序的最后关闭数据库 func demo41() { //随用随开，用完【即】关 fmt.Println(\"打开数据库\") //defer所唤起的函数将在函数结束前才执行 defer closeDatabase() fmt.Println(\"愉快地读写数据\") fmt.Println(\"读写完毕\") } 多个defer时，最早defer的操作最后执行 func demo42() { //打开数据库 fmt.Println(\"打开数据库\") defer closeDatabase() //读入DB数据 fmt.Println(\"读入DB数据\") //打开文件 fmt.Println(\"打开文件\") defer closeFile() //向文件中写出DB中的数据 fmt.Println(\"读入DB数据\") //关闭文件 //继续操作数据库 fmt.Println(\"继续操作数据库\") //关闭数据库 } func closeDatabase() { fmt.Println(\"关闭数据库\") } func closeFile() { fmt.Println(\"关闭文件\") } powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/流程控制4-直接跳转goto.html":{"url":"02GoBase/流程控制4-直接跳转goto.html","title":"直接跳转goto","keywords":"","body":"直接跳转goto 概述 goto SOMEWHERE就是：直接去到标记为SOMEWHERE地方，Go 语言的 goto 语句可以无条件地转移到过程中指定的行。 goto语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。但是，在结构化程序设计中一般不主张使用goto语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。 直接跳转GAMEOVER func main() { //顺序结构 fmt.Println(\"hello\") fmt.Println(\"golang\") //选择结构 if time.Now().Hour()%2 == 1 { fmt.Println(\"情绪稳定\") } else { fmt.Println(\"大姨夫蠢蠢欲动...\") } //循环结构 var i int for { if i > 10 { //去到GAMEOVER标记的地方 goto GAMEOVER } fmt.Println(i) time.Sleep(500 * time.Millisecond) i++ } //这里执行不到 fmt.Println(\"此处免费领取靠海别野一套\") fmt.Println(\"此处免费领取满汉全席一套\") fmt.Println(\"此处免费领取我厂生产的女朋友一个\") GAMEOVER: fmt.Println(\"GAME OVER!\") } powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/函数1-参数和返回值.html":{"url":"02GoBase/函数1-参数和返回值.html","title":"参数和返回值","keywords":"","body":"参数和返回值 函数概述 函数是对一段能够重复使用的代码的封装 函数的参数定义了外界给函数输入的数据 函数的返回值定义了函数给外界输出的数据 Go语言函数执行不定长参数和多个返回值 函数的定义和调用 //定义函数 func sayHello() { fmt.Println(\"fuck off!\") } //调用函数 sayHello() 函数参数 无参函数 func add0() { fmt.Println(\"没参数，add你妹啊\") } 带参函数 func add1(a int) { fmt.Println('收到一个参数',a) fmt.Println(\"没参数，add你妹啊\") } 多个参数 //多个参数 func addm1(a int, b int) { fmt.Println(\"加和是\", a+b) } //类型相同的参数被合写在一起了 func addm2(a, b int) { fmt.Println(\"加和是\", a+b) } //类型不同的参数 func addm3(a, b int, c float32) { fmt.Println(\"加和是\", float32(a)+float32(b)+c) } 不定长参数 func addx(x ...int) { //参数的长度是 5 fmt.Println(\"参数的长度是\", len(x)) //参数的类型是[]int fmt.Printf(\"参数的类型是%T\\n\", x) var result = 0 //遍历不定长参数 for i, v := range x { fmt.Println(i, v) result += v } //加和是 15 fmt.Println(\"加和是\", result) } 函数返回值 无返回 //无返回值 func sub0(a, b int) { fmt.Println(\"相减的结果是\", a-b) } 有返回值 //有返回值 func sub11(a, b int) int { fmt.Println(\"相减的结果是\", a-b) return a - b } func sub12(a, b int) (ret int) { fmt.Println(\"相减的结果是\", a-b) ret = a - b return } 多个返回值 //多个返回值 func subm1(a, b int) (int, string) { fmt.Println(\"相减的结果是\", a-b) return a - b, \"你妹\" } func subm2(a, b int) (ret int, remark string) { fmt.Println(\"相减的结果是\", a-b) ret = a - b remark = \"你妹\" return } powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/函数2-匿名函数.html":{"url":"02GoBase/函数2-匿名函数.html","title":"匿名函数","keywords":"","body":"匿名函数 概述 匿名函数的主要作用是封装一段一次性执行的代码 它无所谓复用，所以无需起名，之所以进行封装的意义，在于使一段代码成为一个整体 defer延时执行一段代码，和go并发执行一段代码是匿名函数的常用场景 //匿名函数 func main() { //延时执行的匿名函数 defer func() { fmt.Println(\"劳资延时·无名，劳资最后执行\") }() //并发执行的匿名函数 go func() { fmt.Println(\"劳资并发·无名，劳资并发执行\") }() //一个带参的匿名函数 ret := func(a, b int) int { fmt.Println(\"劳资普通·无名，下面劳资睡一会\") time.Sleep(1) return a + b }(2, 3) fmt.Println(ret) } powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/函数3-闭包函数.html":{"url":"02GoBase/函数3-闭包函数.html","title":"闭包函数","keywords":"","body":"闭包函数 概述 闭包函数：返回函数的函数 闭包的好处：【内层函数的状态】被保存在闭包中 不使用闭包，就要开辟多个全局变量来保存函数以外的数据 如果说这个函数被多方调用，大家都需要各保存各的数据，那么此时就需要开辟多个全局变量 具体使用哪个全局变量，还要在函数内做判断——增大了重复的代码量，令代码看起来比较垃圾 使用多个全局变量多套副本的索引 //全局变量 var heros = [...]string{\"关胜\", \"林冲\", \"秦明\",\"呼延灼\", \"武松\", \"鲁达\"} //宋江的索引 var index1 = 0 //吴用的索引 var index2 = 0 //脑补卢员外的索引、柴进的索引... func useNormal() { for i := 0; i len(heros)-1 { index1 = 0 } } else { theOne = heros[index2] index2++ if index2 > len(heros)-1 { index2 = 0 } } return theOne } 使用闭包函数 //全局变量 var heros = [...]string{\"关胜\", \"林冲\", \"秦明\",\"呼延灼\", \"武松\", \"鲁达\"} //使用函数闭包的案例 func useClosure() { //得到返回的闭包内函数 fSongjiang := giveHimOne(0) fWuyong := giveHimOne(4) for i := 0; i len(heros)-1 { index = 0 } return name + \":\" + theOne } } powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/读取命令行参数.html":{"url":"02GoBase/读取命令行参数.html","title":"读取命令行参数","keywords":"","body":"读取命令行参数 概述 没有GUI界面的应用程序怎么接收用户的输入呢 除了运行时接收标准用户输入以外，主要就是通过命令行参数了 Go语言提供了读取一揽子所有命令行字符串、读取关键字参数两种方式 其中按名称读取关键字参数是主要的用法，需要大家牢牢掌握 读取所有命令行字符串 func demo51() { //os.Args中封装了用户启动当前程序所使用的所有字符串 fmt.Println(os.Args) //遍历和处理用户在命令行中输入的每一个字符串 for index, value := range os.Args { fmt.Println(index, value) } } 使用系统提供的参数地址 func demo52() { //05xxx.exe -name bill -age 60 -money 1234567890.12 -isstupid true //name=参数名字，value=参数的默认值，usage=参数的说明信息，返回值=存储了【用户输入的参数】的内存地址 namePtr := flag.String(\"name\", \"无名氏\", \"用户名\") agePtr := flag.Int(\"age\", 0, \"年龄\") moneyPtr := flag.Float64(\"money\", 0, \"财富\") isstupidPtr := flag.Bool(\"isstupid\", true, \"是否愚蠢\") //解析参数 flag.Parse() //从上边返回的地址中读取【用户输入的参数】 fmt.Println(*namePtr, *agePtr, *moneyPtr, *isstupidPtr) } 使用自定义的参数地址 func demo53() { //05xxx.exe -name bill -age 60 -money 1234567890.12 -isstupid true //开辟4块内存，用于存储cmd-line参数 var name string var age int var money float64 var isstupid bool fmt.Println(&name, &age, &money, &isstupid) //分别从命令行读取name，age,money,isstupid参数，存入上边开辟的内存地址中 flag.StringVar(&name, \"name\", \"无名氏\", \"用户名\") flag.IntVar(&age, \"age\", 0, \"年龄\") flag.Float64Var(&money, \"money\", 0, \"财富\") flag.BoolVar(&isstupid, \"isstupid\", true, \"是否愚蠢\") //解析命令行参数 flag.Parse() //得到结果 fmt.Println(name, age, money, isstupid) } 人格测试小游戏 func main() { name, age, money, isstupid := getUserInfoFromCmdline() //平均水平：以【40岁有50万标准】=1.0 const k = 1 / (5.0e5 / 40) //成功程度，与money成正比，与age成反比,算出成功指数 successIndex := k * money / float64(age) //富有且认为自己愚蠢的，加分，贫穷且认为聪明的减分 if money > 1.0e6 && isstupid { successIndex *= 1.1 } if money 1 { remark = \"棒棒的\" } else { remark = \"呵呵\" } //姓名用于输出报告 fmt.Printf(\"尊敬的%s阁下：你的成功指数是%.2f,%s\\n\", name, successIndex, remark) } //从命令行读取用户信息 func getUserInfoFromCmdline() (name string, age int, money float64, isstupid bool) { //05xxx.e -name bill -age 60 -money 1234567890.12 -isstupid true //nme=参数名字，value=参数的默认值，usage=参数的说明信息，返回值=存储了【用户输入的参数】的内存地址 namePtr := flag.String(\"name\", \"无名氏\", \"用户名\") agePtr := flag.Int(\"age\", 0, \"年龄\") moneyPtr := flag.Float64(\"money\", 0, \"财富\") isstupidPtr := flag.Bool(\"isstupid\", true, \"是否愚蠢\") //解析参数 flag.Parse() //从上边返回的地址中读取【用户输入的参数】 fmt.Println(*namePtr, *agePtr, *moneyPtr, *isstupidPtr) return *namePtr, *agePtr, *moneyPtr, *isstupidPtr } powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/复合类型1-数组.html":{"url":"02GoBase/复合类型1-数组.html","title":"数组","keywords":"","body":"数组 概述 数组是长度固定，类型固定的数据容器 根据下标访问和修改元素内容 下标从0开始，最后一个元素的下标是长度减一 可以使用len(arr)获得数组的长度 创建数组 func demo71() { //开辟10长度的整型数组 var a1 [10]int //[0 0 0 0 0 0 0 0 0 0] fmt.Println(a1) //开辟10长度的整型数组 var a2 [10]int = [10]int{} //[0 0 0 0 0 0 0 0 0 0] fmt.Println(a2) //创建10长度的整型数组，并给前6项赋值 var a3 = [10]int{0, 1, 2, 3, 4, 5} //[0 1 2 3 4 5 0 0 0 0] fmt.Println(a3) //根据实际元素的个数创建数组，其长度依然是固定不变的 var a4 = [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} //[0 1 2 3 4 5 6 7 8 9] fmt.Println(a4) //同a4，只是声明方式不一样 a5 := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} //[0 1 2 3 4 5 6 7 8 9] fmt.Println(a5) } 修改数组中的元素 根据下标访问元素和修改元素内容 func demo72() { a1 := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} //根据下标访问元素和修改元素内容 a1[6] = 666 //[0 1 2 3 4 5 666 7 8 9] fmt.Println(a1) } 访问数元素+数组遍历 数组的遍历方式有两种 可以通过长度和下标去遍历 还可以通过range关键字，以枚举的方式进行遍历 func demo73() { a1 := [...]int{0, 1, 2, 3, 4, 5, 666, 7, 8, 9} //按照下标访问元素 fmt.Println(a1[6]) //666 fmt.Printf(\"type=%T,len=%d\\n\", a1, len(a1)) //type=[10]int,len=10 //通过下标遍历数组元素 for i := 0; i powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/复合类型2-切片.html":{"url":"02GoBase/复合类型2-切片.html","title":"切片","keywords":"","body":"切片 概述 切片可以理解为长度可以动态变化的数组 切片和数组的相同点1：通过下标来访问元素 切片和数组的相同点2：通过下标或range方式遍历元素 不同点是切片的长度不是固定的，你可以动态地向切片中追加新的元素 切片中可以容纳的元素个数成为容量，容量>=长度 你可以通过len(slice)和cap(slice)分别获取切片的长度和容量 通过make(type,len,cap)的方式你可以创建出自定义初始长度和容量的切片 在追加元素的过程中，如果容量不够用时，就存在动态扩容的问题 动态扩容采用的是倍增策略，即：新容量=2*旧容量 扩容后的切片会得到一片新的连续内存地址，所有元素的地址都会随之发生改变 创建切片 func demob1() { //有类无类冒等三种方式创建出类型、值、长度、容量都相同的切片 var s1 []int = []int{0,1,2} var s2 = []int{0,1,2} s3 := []int{0,1,2} //这里的初始长度和容量是相等的 //type=[]int,value=[0 1 2],len=3,cap=3 fmt.Printf(\"type=%T,value=%v,len=%d,cap=%d\\n\",s1,s1,len(s1),cap(s1)) fmt.Printf(\"type=%T,value=%v,len=%d,cap=%d\\n\",s2,s2,len(s2),cap(s2)) fmt.Printf(\"type=%T,value=%v,len=%d,cap=%d\\n\",s3,s3,len(s3),cap(s3)) //创建长度和容量都为3的切片 s4 := make([]int, 3) fmt.Printf(\"type=%T,value=%v,len=%d,cap=%d\\n\", s4, s4, len(s4), cap(s4)) //创建3长度、4容量的切片 s5 := make([]int, 3, 4) fmt.Printf(\"type=%T,value=%v,len=%d,cap=%d\\n\", s5, s5, len(s5), cap(s5)) } 向切片中追加新的元素 容量每突破一次就翻倍 每翻倍一次，切片就获得一片新的堆地址，每一个元素的地址也都随之发生变化 切片名称的栈地址是不会变的 func demob2() { s := make([]int, 0) s = append(s, 1) //value=[1],len=1,cap=1,saddr=0xc04205c3e0,elemaddr=0xc042062080 fmt.Printf(\"value=%v,len=%d,cap=%d,saddr=%p,elemaddr=%p\\n\", s, len(s), cap(s),&s,&s[0]) s = append(s, 2) //value=[1 2],len=2,cap=2,saddr=0xc04205c3e0,elemaddr=0xc0420620d0 fmt.Printf(\"value=%v,len=%d,cap=%d,saddr=%p,elemaddr=%p\\n\", s, len(s), cap(s),&s,&s[0]) s = append(s, 3) //value=[1 2 3],len=3,cap=4,saddr=0xc04205c3e0,elemaddr=0xc0420600e0 fmt.Printf(\"value=%v,len=%d,cap=%d,saddr=%p,elemaddr=%p\\n\", s, len(s), cap(s),&s,&s[0]) s = append(s, 4) //value=[1 2 3 4],len=4,cap=4,saddr=0xc04205c3e0,elemaddr=0xc0420600e0 fmt.Printf(\"value=%v,len=%d,cap=%d,saddr=%p,elemaddr=%p\\n\", s, len(s), cap(s),&s,&s[0]) s = append(s, 5) //value=[1 2 3 4 5],len=5,cap=8,saddr=0xc04205c3e0,elemaddr=0xc042088100 fmt.Printf(\"value=%v,len=%d,cap=%d,saddr=%p,elemaddr=%p\\n\", s, len(s), cap(s),&s,&s[0]) s = append(s, 6, 7, 8) //value=[1 2 3 4 5 6 7 8],len=8,cap=8,saddr=0xc04205c3e0,elemaddr=0xc042088100 fmt.Printf(\"value=%v,len=%d,cap=%d,saddr=%p,elemaddr=%p\\n\", s, len(s), cap(s),&s,&s[0]) s = append(s, 9) //value=[1 2 3 4 5 6 7 8 9],len=9,cap=16,saddr=0xc04205c3e0,elemaddr=0xc042092080 fmt.Printf(\"value=%v,len=%d,cap=%d,saddr=%p,elemaddr=%p\\n\", s, len(s), cap(s),&s,&s[0]) } 兼并其他切片 func demob3() { s := make([]int, 0) s = append(s, 1, 2, 3) s2 := []int{4, 5, 6} //追加s2中所有元素到s，注意这里的写法 s = append(s, s2...) fmt.Println(\"s=\",s) fmt.Println(\"s2=\",s2) } 截取数组或切片，获得切片 截取方式：son := father[start:end] start不写默认从开头截取 end不写默认截取到末尾 func demob4() { var a [10]int = [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} //在数组的基础上截取，得到切片 as1 := a[2:8] fmt.Printf(\"type=%T,value=%v\\n\", as1, as1) //截取的方式[头下标:尾下标]，含头不含尾,不写头默认头=0，不写尾默截取到最后一位 as2 := a[:8] as3 := a[2:] as4 := a[:] fmt.Println(as2, as3, as4) } 切片和底层数组/切片的关系 一开始切片引用底层数组的元素地址——切片和数组内容的修改会相互影响 切片扩容到突破原有容量时，就拷贝内容到新的地址——此时就已经完全脱离了底层数组 func demob5() { var a [10]int = [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} //切片不是值拷贝，而是直接底层数组地址 as1 := a[:5] as2 := as1[:] //[0 1 2 3 4] [0 1 2 3 4] fmt.Println(as1, as2) //0xc0420140a0,0xc0420140a0,0xc0420140a0 fmt.Printf(\"%p,%p,%p\\n\", &a[0], &as1[0], &as2[0]) //切片不是值拷贝，而是直接底层数组地址 as1[0] = 123 as2[1] = 38 //[123 38 2 3 4 5 6 7 8 9] [123 38 2 3 4] [123 38 2 3 4] fmt.Println(a, as1, as2) //扩容突破了容量(cap)的上限，切片拷贝得到新的元素地址，脱离了原先的底层数组 //before:cap=10,addr=0xc04205c3e0,elemaddr=0xc042090000 fmt.Printf(\"before:cap=%d,addr=%p,elemaddr=%p\\n\", cap(as2), &as2, &as2[0]) as2 = append(as2, 666, 777, 888,999,1000,1100,1100) //after:cap=20,addr=0xc04205c3e0,elem addr=0xc042094000 fmt.Printf(\"after:cap=%d,addr=%p,elemaddr=%p\\n\", cap(as2), &as2, &as2[0]) as2[0] = 90000 //打印的结果就是：as2脱离了a和as1，自成一家 fmt.Println(a, as1, as2) a[0] = 0 fmt.Println(a, as1, as2) } 拷贝src切片，覆盖dst切片 func demob6() { //var dst = []int{1,2,3,4} //var src = []int{10,20,30,40} //var dst = []int{1,2,3,4} //var src = []int{10,20,30,40,50} var dst = []int{1, 2, 3, 4, 5, 6} var src = []int{10, 20, 30, 40} //src中的元素从头覆盖dst中的元素，返回受影响的元素个数 n := copy(dst, src) fmt.Println(dst, n) } 遍历访问切片元素 func demob7() { s := make([]int, 0) s = append(s, 10, 20, 30, 40, 50) for index, value := range s { fmt.Println(index, value) } } powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/复合类型3-映射.html":{"url":"02GoBase/复合类型3-映射.html","title":"映射","keywords":"","body":"映射 概念 映射（map）是键值对形成的集合 键值的类型都是任意的 可以根据键快速的查询值，而无须遍历 创建map 可以通过声明map[keytype]valuetype的方式创建map 也可以通过make(map[keytype]valuetype,size)的方式来创建，size不指定时默认长度为0 以map[key]和map[key]=value的方式可以访问和修改键值 func demo81() { //var mmp = map[string]int{} //var mmp map[string]int //var mmp = map[string]int{\"代码量\":10000,\"酒量\":20} //通过内建函数make创建 //mmp := make(map[string]int) //创建一个string为键，值为任意类型的map mmp := make(map[string]interface{}) //丢入键值对到map中 mmp[\"name\"]=\"西门东\" mmp[\"sex\"]=\"male\" mmp[\"hobby\"]=\"female\" mmp[\"rmb\"]=0.5 fmt.Printf(\"type=%T,value=%v,len=%d\\n\", mmp, mmp, len(mmp)) } 删除键值对 通过内置函数delete(map,key)的方式可以删除一个键值对 func demo82() { //创建一个string为键，值为任意类型的map mmp := make(map[string]interface{}) //丢入键值对到map中 mmp[\"name\"] = \"西门东\" mmp[\"sex\"] = \"male\" mmp[\"hobby\"] = \"female\" mmp[\"rmb\"] = 0.5 //删除hobby对应的键值对 delete(mmp, \"hobby\") fmt.Println(mmp) } 修改键值对 func demo83() { //创建一个string为键，值为任意类型的map mmp := make(map[string]interface{}) //丢入键值对到map中 mmp[\"name\"] = \"西门东\" mmp[\"sex\"] = \"male\" mmp[\"hobby\"] = \"female\" mmp[\"rmb\"] = 0.5 //修改特定的键值对 mmp[\"hobby\"] = [...]string{\"抽烟\", \"喝酒\", \"去浪\"} mmp[\"rmb\"] = -29999.5 mmp[\"最爱的书籍\"] = \"平凡的世界\" fmt.Println(mmp) } map的查询和遍历 可以通过value := map[key]的方式得到key对应的value，当key不存在时得到的是nil 为了避免访问一个并不存在的键得到空值带来的逻辑错误，可以通过value,ok:=map[key]的方式进行带校验的查询，当ok为true时代表有值，否则代表key并不存在 range关键字对map的遍历，可以同时得到键值对的key和value，也可以仅仅得到key func demo_map() { //创建一个string为键，值为任意类型的map mmp := make(map[string]interface{}) //丢入键值对到map中 mmp[\"name\"] = \"西门东\" mmp[\"sex\"] = \"male\" mmp[\"hobby\"] = \"female\" mmp[\"rmb\"] = 0.5 //没有校验的查询，当key不存在时value为 value1 := mmp[\"sex\"] fmt.Println(\"sex=\",value1) value1 = mmp[\"sex2\"] //sex2= fmt.Println(\"sex2=\",value1) //带有校验的查询 value2, ok := mmp[\"最爱的书\"] if ok == true { fmt.Println(value2) } else { fmt.Println(\"东哥：洒家没有最爱的书，查你妹\") } //遍历键值 for key, value := range mmp { fmt.Println(key, value) } //遍历所有键 fmt.Println(\"key := range mmp\") for key := range mmp { fmt.Println(key) } } powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/复合类型4-指针.html":{"url":"02GoBase/复合类型4-指针.html","title":"指针","keywords":"","body":"指针 概述 指针就是地址，指针变量的值就是内存中的一块地址编号 所有普通类型都有对应的指针类型：int,float64,bool,book,[10]int,map[string]interface{} 对指针变量的打印推荐使用%p占位符，代表以地址的形式打印 对普通变量取地址： agePtr := &age 取地址中的值：age := *agePtr 对普通变量取地址VS对指针变量取值 func demo_ptr() { //声明普通变量 var age int = 20 //对age取地址，赋值给整型指针agePointer var agePointer *int = &age //类型：整型指针，值：age的内存地址 //type=*int,value=0xc042062080 fmt.Printf(\"type=%T,value=%p\\n\", agePointer, agePointer) //*agePointer取地址中的值，20 fmt.Println(\"agePointer所指向的地址中的值\", *agePointer) } 存放指针的指针 func demoa2() { var age int = 20 //agePtr中存放的是age的内存地址 var agePtr *int = &age //apPtr是一个指向指针（agePtr）的指针 var apPtr **int = &agePtr //type=**int,value=0xc042082018 fmt.Printf(\"type=%T,value=%p\\n\", apPtr, apPtr) //*apPtr得到agePtr（存放age的地址），*（*apPtr）得到age的值20 fmt.Println(**apPtr) } powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/复合类型5-结构体.html":{"url":"02GoBase/复合类型5-结构体.html","title":"结构体","keywords":"","body":"结构体 定义结构体 type book struct { //书名属性 name string //价格属性 price float64 } 创建对象时直接对属性赋值 func demo91() { b := book{\"水许传\",34.56} fmt.Printf(\"type=%T，value=%#v\\n\",b,b) } 创建空白对象，并逐一对属性赋值 func demo92() { b := book{} b.name = \"水许传\" b.price = 34.56 fmt.Printf(\"type=%T，value=%#v\\n\", b, b) } 创建对象指针并给属性赋值 内置函数new(Type) 可以创建任意类型的对象，并获得其指针 通过结构体指针访问结构体的成员，与通过值来访问，写法上是一模一样的 func demo93() { //创建book指针 bookPtr := new(book) fmt.Printf(\"type=%T，value=%#v,address=%p\\n\", bookPtr, *bookPtr, bookPtr) //结构体指针给属性赋值的方式，与结构体对象一模一样 bookPtr.name = \"水许传\" bookPtr.price = 34.56 fmt.Println(*bookPtr) } 工具函数：通过值传递查看结构属性 func showBookInfo(b book) { fmt.Println(b.name) fmt.Println(b.price) } 分别通过指针和值来访问结构体的属性 值传递是拷贝式的，传递的是一个副本 值传递中，无论外界函数如何修改被传参数，都不会影响到本体 引用传递，传递的是对象的地址 引用传递对被传参数的修改，将直接改变本体！ func demo94() { b1 := book{\"三国\", 45.67} showBookInfo(b1) showBookInfo2(&b1) bp := new(book) bp.name = \"三国\" bp.price = 45.67 showBookInfo(*bp) showBookInfo2(bp) } powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/SDK标准库1-strings.html":{"url":"02GoBase/SDK标准库1-strings.html","title":"strings","keywords":"","body":"strings 概述 strings库定义了对字符串的常用处理操作 常用的包括：检索子串、格式化、比较大小、裁剪、拼接、炸碎等 func main() { //判断是否包含子串 fmt.Println(strings.Contains(\"Hello\", \"shit\")) //false fmt.Println(strings.Contains(\"Hello\", \"lo\")) //true fmt.Println(strings.ContainsAny(\"Hello shit\", \"ae\")) //true 因为包含ae中的e fmt.Println(strings.ContainsAny(\"Hello shit\", \"azx\")) //false 母串中不包含azx中的任何一个字母 fmt.Println(strings.ContainsRune(\"Hello\", 'o')) //true 判断是否包含某字符 fmt.Println(strings.ContainsRune(\"Hello\", 'x')) //false //返回子串索引 fmt.Println(strings.Index(\"Hello shit\", \"shit\")) //6 fmt.Println(strings.Index(\"Hello shit\", \"shiter\")) //-1 //格式化 fmt.Println(strings.Title(\"hello shit\")) //Hello Shit 每个单词的首字母为【标题格式】 fmt.Println(strings.ToTitle(\"ShIt\")) //SHIT 单词的每个字母为【标题格式】 fmt.Println(strings.ToUpper(\"ShIt\")) //SHIT 全大写 fmt.Println(strings.ToLower(\"ShIt\")) //shit 全小写 //比较大小 fmt.Println(strings.Compare(\"azzz\", \"zaaa\")) //-1 fmt.Println(strings.Compare(\"z\", \"a\")) //1 fmt.Println(strings.Compare(\"a\", \"a\")) //0 //裁剪 fmt.Println(strings.Trim(\" hello shit \", \" \")) //hello shit 收尾的空白都没有了 fmt.Println(strings.Trim(\" hello shit .,\", \" ,\")) //去除【头尾】的所有【逗号和空白】，【头尾】是由cutset中的字符连续排列的区域 fmt.Println(strings.Trim(\", ,, ,hello shit ., , , \", \", \")) fmt.Println(strings.TrimLeft(\", ,, ,hello shit ., , , \", \", \")) //左侧修剪的干干净净，右侧一屁股翔 fmt.Println(strings.TrimRight(\", ,, ,hello shit ., , , \", \", \")) //右侧修剪的干干净净，左侧一屁股翔 //最后一个参数func允许你自定义裁剪规则，返回true的将被视为可以裁剪的字符 fmt.Println(strings.TrimFunc(\", ,, ,hello shit ., , , \", func(r rune) bool { if r == ' ' || r == ',' || r == '.' { return true } return false })) fmt.Println(strings.TrimPrefix(\"-hello shit ., , , -\", \"-\")) //修剪前缀 fmt.Println(strings.TrimSuffix(\"-hello shit ., , , -\", \"-\")) //修剪前缀 fmt.Println(strings.TrimSpace(\" hello shit \")) //判断是否相等 fmt.Println(strings.EqualFold(\"HelloShit\", \"heLLoSHIT\")) //true 忽略大小写和标题的差异后，是否依然相同 //炸碎 fmt.Println(strings.Fields(\"hello shit eater\")) //[hello shit eater] 以空白为分隔符，将字符串炸开为子串的切片 fmt.Println(strings.Fields(\"hello,shit eater,devourer\")) //[hello,shit eater,devourer] //在func中自定义分隔符的规则 fmt.Println(strings.FieldsFunc(\"hello,shit eater,devourer\", func(r rune) bool { if r == ' ' || r == ',' { return true } return false })) //[hello shit eater devourer] //炸碎 /* func Split(s, sep string) []string func SplitN(s, sep string, n int) []string func SplitAfter(s, sep string) []string func SplitAfterN(s, sep string, n int) []string */ fmt.Println(strings.Split(\"hello,world,hello,shitEater\",\",\"))//[hello world hello shitEater] fmt.Println(strings.SplitN(\"hello,world,hello,shitEater\",\",\",2))//[hello world,hello,shitEater] fmt.Println(strings.SplitAfter(\"hello,world,hello,shitEater\",\",\"))//[hello, world, hello, shitEater] fmt.Println(strings.SplitAfterN(\"hello,world,hello,shitEater\",\",\",2))//[hello, world,hello,shitEater] //拼接 fmt.Println(strings.Join([]string{\"hello\",\"world\",\"hello\",\"shitEater\"},\"$\"))//hello$world$hello$shitEater fmt.Println() } powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/SDK标准库2-math.html":{"url":"02GoBase/SDK标准库2-math.html","title":"math","keywords":"","body":"math package main import ( \"math/big\" \"fmt\" ) func main() { //创建大数（值可以突破int64） bigInt1 := big.NewInt(123) bigInt2 := new(big.Int) bigInt2.SetString(\"314159265358979323846264338327950288419716939937510582097494459\", 10) fmt.Printf(\"type=%T,value=%v\\n\",bigInt1,bigInt1) fmt.Printf(\"type=%T,value=%v\\n\",bigInt2,bigInt2) //大数的计算 bigx := big.NewInt(1) big1 := big.NewInt(11) big2 := big.NewInt(3) fmt.Println(bigx.Add(big1, big2),bigx)//14 fmt.Println(bigx.Sub(big1, big2),bigx)//8 fmt.Println(bigx.Mul(big1, big2),bigx)//33 fmt.Println(bigx.Div(big1, big2),bigx)//3 fmt.Println(bigx.Mod(big1, big2),bigx)//2 fmt.Println(bigx.And(big1, big2),bigx)//3 fmt.Println(bigx.Or(big1, big2),bigx)//11 fmt.Println(bigx.Xor(big1, big2),bigx)//8 //每一步的结果都重新给bigx赋值，所以事实上得到的是最后一步的结果 fmt.Println(bigx.Add(big1,big2).Sub(big1,big2).Mul(big1,big2).Div(big1,big2)) //(11+3)*2%3=1 fmt.Println(bigx.Mod((bigx.Mul((bigx.Add(big1, big2)),big.NewInt(2))),big.NewInt(3))) } powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"02GoBase/SDK标准库3-os.html":{"url":"02GoBase/SDK标准库3-os.html","title":"os","keywords":"","body":"os 概述 os包封装了操作系统提供给Go的API 常用的包括：读取系统信息、读取环境变量、读取和修改文件信息等 package main import ( \"os\" \"fmt\" \"time\" ) func main() { //获得当前工作路径 //D:\\BJBlockChain1801\\demos\\ dir, _ := os.Getwd() fmt.Println(dir) //读取环境变量 //D:\\iWorkspace\\GoPros\\Go18DaysCode\\Day13project\\;C:\\Users\\sirouyang\\go;D:\\BJGo1801Pre\\preWorks\\predemos\\W99\\03标准库\\38单元测试 paths := os.Getenv(\"GOPATH\") fmt.Println(paths) //修改文件的访问时间 os.Chtimes(\"d:/temp/小黑子.avi\",time.Now(),time.Now()) //获得黄精变量 environ := os.Environ() fmt.Println(environ) //获得主机名 fmt.Println(os.Hostname()) fmt.Println(os.IsPathSeparator('/'))//Linux认 fmt.Println(os.IsPathSeparator('\\\\'))//Linux不认 //获得文件状态信息 fileInfo1, _ := os.Stat(\"d:/temp/小黑子2.avi\") fileInfo2, _ := os.Stat(\"d:/temp/小黑子\"+\"2\"+\".avi\") fmt.Println(os.SameFile(fileInfo1,fileInfo2)) //获得用户临时文件夹所在位置 fmt.Println(os.TempDir()) } powered by Gitbook修订时间： 2020-04-28 10:18:02 "},"03GoObject/面向对象1-封装.html":{"url":"03GoObject/面向对象1-封装.html","title":"封装","keywords":"","body":"封装 面向对象概述 在没有面向对象的年代，编程的方式是面向过程的 面向过程的编程，管理的是一个一个的函数，撸工程就是堆砌大量的函数 面向对象中类的概念，Go语言是通过结构体来实现的 类/结构体是对函数的进一步封装，即把有机关联的变量和函数封装为一个结构体 有了类/结构体的概念以后，撸工程就由管理大量的函数变为了管理少量的类 书本理论中面向函数的三大特性是：封装、继承、多态（有时会再加一个抽象） 继承性实现了低成本地扩展原有代码 多态性实现了大规模代码的组装和调度 面向对象使工程开发变成了搭建框架和组装模块的游戏 面向对象的出现使大规模协作与大规模开发变得更容易了 封装性概述 封装就是将业务逻辑相近的变量和函数封装在一起，成为一个结构体 被封起来的变量称之为属性 被封起来的函数称之为方法 封装的意义，在于整理和简化代码结构 封装也是继承和多态的基础 封装结构体 //定义结构体 type Dog struct { //定义狗的属性 name string sex int } /*封装狗的方法*/ //setter func (d *Dog)SetName(name string) { //在这里可以加一些权限校验 d.name = name } //getter func (d *Dog)GetName() string { //在这里可以加一些权限校验 return d.name } //定义咬人方法 func (d *Dog)bite() { fmt.Printf(\"让本汪%s来给你一些震撼教育...\",d.name) } 创建空白对象并给属性赋值 func demo21() { //创建空白对象 d := Dog{} //给对象的属性赋值 d.name = \"臭皮\" d.sex = 1 fmt.Println(d.sex) d.bite() } 创建对象的同时有序而完整的给属性赋值 func demo22() { //创建对象的同时有序而完整地给属性赋值 d := Dog{\"臭皮\", 1} fmt.Println(d.sex) d.bite() } 创建对象并有选择的给属性赋值 func demo23() { d := Dog{name: \"臭皮\"} d.sex = 1 d.SetName(\"旺财\") fmt.Println(d.GetName()) d.bite() } 创建空白指针对象并给属性赋值 func demo24() { dp := new(Dog) //通过【指针】访问结构体的【成员】（包括属性和方法）和通过【值】访问一模一样 dp.SetName(\"臭皮\") dp.bite() } 使用工厂模式创建对象 封装【创建实例的重复复杂过程】为固定的套路和【模式】 以后就可以【反反复复】、【轻松加愉快】地复用模式和套路了 正所谓【自古真情没卵用，唯有套路得人心】，阿门 这个一次封装、反复玩弄的套路，就称为【工厂模式】 工厂模式——将造实例这件事情做专业化的封装，并反复调用 //工厂方法 func NewDog(name string,sex int) *Dog { d := new(Dog) d.name = name d.sex = sex return d } //使用工厂模式创建对象 func demo25() { xiaohei := NewDog(\"小黑\", 1) xiaohei.bite() } powered by Gitbook修订时间： 2020-04-28 10:18:03 "},"03GoObject/面向对象2-继承.html":{"url":"03GoObject/面向对象2-继承.html","title":"继承","keywords":"","body":"继承 继承性概述 继承的意义在于低成本地扩展和改造原有代码 首先，子类一行代码即可拥有父类的全部成员（属性和方法） 继承的目的，在于扩展和改造父类 扩展，是指子类发展出自己独有的新属性和新方法，以适应自身需求 改造，是指子类覆写和覆盖父类成员（属性和方法），以适应自身需求 定义父类 //定义父类 type Doggy struct { name string sex bool } //定义父类方法 func (d *Doggy) bite() { fmt.Printf(\"%s要咬你了啊\\n\",d.name) } 定义子类 //定义子类 type PoliceDog struct { //持有一个Doggy对象，并继承Doggy的全部属性和方法 Doggy //警犬所独有的属性 skill string } //覆写父类方法 func (pd *PoliceDog) bite() { fmt.Printf(\"%s:还没出嘴你就熏晕过去了，我他妈刚喝了三瓶茅台\\n\",pd.name) } //发展出新的方法 func (pd *PoliceDog)doPoliceJob() { fmt.Printf(\"%s正在执行警务工作,普通的狗狗是做不到滴\",pd.name) } 继承了Doggy的PoliceDog拥有父类的全部属性和方法 func demo31() { pdPtr := new(PoliceDog) pdPtr.name = \"战狼\" pdPtr.bite() } 继承的目的是为了有新的扩展 func demo32() { pdPtr := new(PoliceDog) //这里是从父类继承过来的属性和方法 pdPtr.name = \"战狼\" pdPtr.bite() //访问独有的属性和方法 pdPtr.skill = \"徒手接RPG\" fmt.Println(pdPtr.skill) pdPtr.doPoliceJob() } 直接在声明子类时完成属性的重定义 func demo33() { pd := PoliceDog{Doggy{\"战狼II\", true}, \"豪饮\"} pd.bite() } powered by Gitbook修订时间： 2020-04-28 10:18:03 "},"03GoObject/面向对象3-多态.html":{"url":"03GoObject/面向对象3-多态.html","title":"多态","keywords":"","body":"多态 多态概述 多态是指，一个父类接口可以拥有多种子类实现形态 这些子类形态之间有相同点，那就是它们都实现了父类接口中的方法 不同点则是大家对父类接口方法的实现方式各不相同，演绎何为千姿百态 例如，定义一个父类接口战士，凡战士者势必能攻能守，所以定义两个抽象方法：进攻与防守，但不做具体实现 骑兵、步兵、法师都能杀敌护国，他们是战士接口的三个子类实现 所以他们的共性是：都有进攻方法与防守方法 而他们的不同点是：具体的进攻方式各不相同，具体的防守方式也各不相同 所以当我拥有一个战士的集合时，我可以无视其具体类型，管你骑兵步兵还是法师弓箭手，都给劳资进攻，这就是调度它们的共性 当敌人的大军来势汹汹时，最好的问候就是先给他们来一轮万箭齐发，这时我要从战士的集合里找出弓箭手这个具体实现，使用弓箭手的进攻方法（而非步兵的进攻方法因为无法满足需求），这就是调度它们的个性 多态、共性与个性，使程序变得既丰富又简单 定义父类接口 //战士接口 type Soldier interface { Attack() (bloodLoss int) Defend() } 定义子类实现一 //骑兵：战士的实现形态一 type Rider struct{} //骑兵的进攻与防守 func (r *Rider) Attack() (bloodLoss int) { fmt.Println(\"发动战争践踏，撞死你，踩死你，扎死你\") return 50 } func (r *Rider) Defend() { fmt.Println(\"不能跑，我得快点走\") } 定义子类实现二 //法师：战士的实现形态二 type Master struct{} //法师的进攻与防守 func (r *Master) Attack() (bloodLoss int) { fmt.Println(\"天崩地裂，电闪雷鸣，群星坠落，万籁俱寂，遍布下去了...\") return 10000 } func (r *Master) Defend() { fmt.Println(\"回城\") } 不同场景下，时而共性，时而个性 func main() { //定义一个战士的集合，加入不同的子类实现 soldiers := make([]Soldier, 0) soldiers = append(soldiers, new(Rider)) soldiers = append(soldiers, new(Master)) //强调共性时 fmt.Println(\"全体进攻\") for _, f := range soldiers { //所有子类实现都调用共同的父类方法 f.Attack() } //强调个性时 fmt.Println(\"敌寇势大，法师进攻，骑士防守\") for _, s := range soldiers { /* //类型断言方式1 switch s.(type) { case *Rider: s.Defend() case *Master: s.Attack() default: fmt.Println(\"来了个什么鬼...\") }*/ //类型断言方式2 //判断是当前s实例是不是骑士 // 如果是:ok为true，riderPtr有值 //如果不是：ok为false，riderPtr为nil if riderPtr, ok := s.(*Rider); ok { riderPtr.Defend() } //判断是当前s实例是不是法师 // 如果是:ok为true，masterPtr有值 //如果不是：ok为false，masterPtr为nil if masterPtr, ok := s.(*Master); ok { masterPtr.Attack() } } } powered by Gitbook修订时间： 2020-04-28 10:18:03 "},"03GoObject/面向对象4-接口与实现.html":{"url":"03GoObject/面向对象4-接口与实现.html","title":"接口与实现","keywords":"","body":"接口与实现 接口与实现 接口定义了一组共性 这些共性体现为接口的抽象方法 抽象方法就是只有方法定义，没有方法实现的方法 接口里有且只有抽象方法 接口可以有多种不同的具体子类实现 接口的作用是为子类实现提供统一的API 定义接口 //定义【USB设备】接口 //接口：只包含抽象方法 type USBDevice interface { /*定义了三个【抽象方法】：定义而不做实现*/ //连接电脑，返回值代表连接是否成功 Connect() bool //读取数据，读到的数据 ReadData() []byte //断开连接，返回值代表连接是否成功 Disconnct() bool } 接口实现 //USB设备的优盘实现 type Upan struct { //定义容量 storage int } /*优盘实现USBDevice接口中定义的全部抽象方法=实现了USBDevice接口*/ func (up *Upan)Connect() bool { fmt.Println(\"优盘连接成功\") return true } func (up *Upan)ReadData() []byte { fmt.Println(\"优盘连接成功\") return []byte(\"东哥撸无码艺术.avi\") } func (up *Upan)Disconnct() bool { fmt.Println(\"优盘已断开连接\") return true } 用子类实现去赋值父类对象 func main() { //定义接口对象 var usbDevice USBDevice //用具体实现类去为接口赋值 up := Upan{8 * 1024 * 1024 * 1024} usbDevice = &up //操作usb设备 usbDevice.Connect() fmt.Println(usbDevice.ReadData()) usbDevice.Disconnct() } powered by Gitbook修订时间： 2020-04-28 10:18:03 "},"03GoObject/面向对象5-接口的继承.html":{"url":"03GoObject/面向对象5-接口的继承.html","title":"接口的继承","keywords":"","body":"接口的继承 定义两个父类接口 //定义动物接口：所有动物都会新陈代谢，都会挂掉 type Animal interface { //新陈代谢：吃进来+排出去,shit就是翔啊~ Eat(food string) (shit string) //GAME OVER Die() } //定义战士接口，会进攻和防守 type Fighter interface { //进攻并造成对手掉血 Attack() (bloodLoss int) Defend() } 显式地继承父类接口 //野兽接口，拥有动物的一切特征 //野兽接口，拥有战士的一切特征 type Beast interface { //野兽接口继承动物接口 Animal //野兽接口继承斗士接口 Fighter Run() } 隐式继承父类接口 type Beast interface { //显式继承动物接口 Animal //隐式继承斗士接口：没有明确地说继承斗士，但事实上定义了其全部抽象方法 Attack() (bloodLoss int) Defend() //野兽特有的方法 Run() } 实现Beast接口 type Tiger struct { name string food string shit string power int } /*实现野兽的全部方法才算是野兽*/ func (t *Tiger)Eat(food string) (shit string) { fmt.Printf(\"本王正在享用%s,并撇下%s\\n\",t.food,t.shit) return t.shit } func (t *Tiger)Die() { fmt.Printf(\"大猫%s也有狗带的一天啊，啊啊啊啊...\\n\",t.name) } func (t *Tiger)Attack() (bloodLoss int) { fmt.Printf(\"本王咬你，掉血%d毫升\\n\",t.power) return t.power } func (t *Tiger)Defend() { fmt.Println(\"躺在地上举高高，我不是在卖萌，而是在防守\") } func (t *Tiger)Run() { fmt.Println(\"本王在奔跑\") } 使用接口实例 func main() { tiger := &Tiger{\"东北虎\", \"其它野兽\", \"虎翔\", 1024} var animal Animal var fighter Fighter var beast Beast //老虎既是动物，又是斗士，又是野兽 //用子类实现去给父类接口赋值 animal = tiger fighter = tiger beast = tiger //调用父类接口方法 animal.Eat(\"食物\") animal.Die() fighter.Attack() fighter.Defend() beast.Run() } powered by Gitbook修订时间： 2020-04-28 10:18:03 "},"04FileIO/文件操作1-文件读写的一般操作.html":{"url":"04FileIO/文件操作1-文件读写的一般操作.html","title":"文件读写的一般操作","keywords":"","body":"文件读写的一般操作 导入依赖 import ( \"os\" \"fmt\" \"time\" \"bufio\" \"io\" \"io/ioutil\" ) 打开和关闭文件 func main41() { //打开文件 filePtr, err := os.Open(\"d:/小黑子.avi\") if err != nil { fmt.Println(\"文件打开失败,err=\", err) } else { fmt.Println(\"文件打开成功\") } //关闭 //defer filePtr.Close() defer func() { filePtr.Close() fmt.Println(\"文件已关闭\") }() fmt.Println(\"愉快滴欣赏avi艺术\") time.Sleep(3 * time.Second) } 读取数据 func main42() { //打开和关闭文件 //os.O_RDONLY 以只读模式打开 //0765 文件主人的权限7（4+2+1=可读+可写+可执行），文件的用户组下的人的权限6（4+2=可读+可写），其他人的权限5（4+1=可读+可执行） filePtr, err := os.OpenFile(\"d:/abc.txt\", os.O_RDONLY, 0765) if err != nil { fmt.Println(\"文件打开失败,err=\", err) return } else { fmt.Println(\"打开文件成功\") } //打开时立即挂起关闭程序 defer func() { defer filePtr.Close() fmt.Println(\"文件已关闭\") }() //创建文件的读取器 reader := bufio.NewReader(filePtr) //循环读取 for { //以换行符为界，分批次读取数据，得到str（str中包括一个换行符） str, err := reader.ReadString('\\n') if err != nil { fmt.Println(\"读取失败,err=\", err) //如果已到文件末尾，就结束循环 if err == io.EOF { break } } //打印读到的内容 fmt.Print(str) } fmt.Println(\"读取结束\") } 读取数据2 func main43() { bytes, err := ioutil.ReadFile(\"d:/abc.txt\") if err != nil { fmt.Println(\"读取失败，err=\", err) } else { contentStr := string(bytes) fmt.Println(contentStr) } } 写入数据 写入数据分三种模式 创写模式 覆写模式 追加模式 func main44() { //打开并延时关闭文件 //创写模式 //file, err := os.OpenFile(\"d:/大黑子.avi\", os.O_CREATE|os.O_WRONLY, 0754) //覆写模式 //file, err := os.OpenFile(\"d:/兄弟连.txt\", os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0754) //追加模式 file, err := os.OpenFile(\"d:/兄弟连.txt\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0754) if err != nil { fmt.Println(\"文件打开失败,err=\", err) return } else { fmt.Println(\"打开文件成功\") } defer file.Close() //创建写入器 writer := bufio.NewWriter(file) //执行带缓冲的写入 writer.WriteString(\"大海啊你全他妈是水\\n\") writer.WriteString(\"蜘蛛啊你全他妈是腿\\n\") writer.WriteString(\"辣椒啊真他妈辣嘴\\n\") writer.WriteString(\"不好好学习真他妈后悔\\n\") //强制将缓冲区中的内容写入文件 writer.Flush() fmt.Println(\"写入成功！\") } 判断文件是否存在 func CheckIfFileExist(filename string) (exists bool, info string) { fileInfo, err := os.Stat(filename) fmt.Println(fileInfo, err) if fileInfo != nil && err == nil { fmt.Printf(\"%s文件存在\\n\", filename) exists = true } else if os.IsNotExist(err) { fmt.Printf(\"%s文件不存在\\n\", filename) exists = false } else { fmt.Println(\"搞不清存不存在!\") exists = false info = \"发生了一些奇奇怪怪的事情...\" } return } func main45() { CheckIfFileExist(\"d:/小黑子.avi\") CheckIfFileExist(\"d:/小白子.avi\") } 快捷写入 func main46() { //默认模式：os.O_WRONLY|os.O_CREATE|os.O_TRUNC=只写+不存在就创建+【覆写模式】 err := ioutil.WriteFile(\"d:/abc.txt\", []byte(\"再看我\\n再看我就把你喝掉\"), 0754) if err != nil { fmt.Println(\"写入失败\") } else { fmt.Println(\"写入成功\") } fmt.Println(\"写入结束\") } powered by Gitbook修订时间： 2020-04-28 10:18:03 "},"04FileIO/文件操作2-实战案例.html":{"url":"04FileIO/文件操作2-实战案例.html","title":"实战案例","keywords":"","body":"实战案例 导入依赖 import ( \"fmt\" \"io\" \"os\" \"io/ioutil\" ) 文件拷贝1 func copyFile(srcFilename string,dstFilename string) { bytes, _ := ioutil.ReadFile(srcFilename) err := ioutil.WriteFile(dstFilename, bytes, 0754) if err != nil { fmt.Println(\"拷贝失败，err=\", err) } else { fmt.Println(\"拷贝成功!\") } } func main51() { copyFile(\"d:/找你妹.txt\",\"d:/找自己.txt\") } 文件拷贝2 func main52() { //打开来源文件和目标文件（目标文件可能并不存在） srcFile, _ := os.OpenFile(\"d:/找你妹.txt\", os.O_RDONLY, 0666) dstFile, _ := os.OpenFile(\"d:/找我妹.txt\", os.O_WRONLY|os.O_CREATE, 0666) //程序的最后关闭这两个文件 defer srcFile.Close() defer dstFile.Close() //使用标准库提供的API实现文件拷贝，返回的是拷贝的字节数 written, err := io.Copy(dstFile, srcFile) if err!=nil{ fmt.Println(\"拷贝失败,err=\",err) }else{ fmt.Println(\"拷贝成功,字节数=\",written) } } 实现文件字符数统计 func CountCharsOfFile(path string)map[string]int { bytes, _ := ioutil.ReadFile(path) str := string(bytes) var numberCount,letterCount,spaceCount,othersCount int //遍历字符串中的每个字符 for i,c := range str{ fmt.Printf(\"No%d,%c\\n\",i,c) //逐个判断每个字符在字符集中的序号 switch { case c >= '0' && c= 'a' && c= 'A' && c powered by Gitbook修订时间： 2020-04-28 10:18:03 "},"05JSONIO/JSON读写1-JSON序列化.html":{"url":"05JSONIO/JSON读写1-JSON序列化.html","title":"JSON序列化","keywords":"","body":"JSON序列化 概述 序列化：将Go数据转化为json字符串 定义结构体 type Person struct { Name string Age int Sex bool Hobbies []string } 定义数据 var ( zhangqd, mutz Person ps []Person mMap, yMap map[string]interface{} mSlice []map[string]interface{} ) 初始化数据 func init() { //初始化结构体数据 zhangqd = Person{\"张全蛋\", 20, true, []string{\"质检\", \"维护流水线\", \"打饭\"}} mutz = Person{\"穆铁花\", 23, false, []string{\"搞破坏\", \"维护流水线\", \"打人\"}} ps = make([]Person, 0) ps = append(ps, zhangqd, mutz) //初始化map数据 mMap = make(map[string]interface{}) mMap[\"name\"] = \"张全蛋\" mMap[\"age\"] = 20 mMap[\"sex\"] = true mMap[\"hobbies\"] = []string{\"质检\", \"维护流水线\", \"打饭\"} yMap = make(map[string]interface{}) yMap[\"name\"] = \"穆铁柱\" yMap[\"age\"] = 23 yMap[\"sex\"] = false yMap[\"hobbies\"] = []string{\"破坏\", \"维护流水线\", \"打人\"} //初始化切片数据 mSlice = make([]map[string]interface{}, 0) mSlice = append(mSlice, mMap, yMap) } 序列化结构体 func main11() { //bytes, err := json.Marshal(zhangqd) bytes, err := json.Marshal(ps) if err != nil { fmt.Println(\"序列化失败,err=\", err) } else { jsonStr := string(bytes) fmt.Println(\"序列化结果：\", jsonStr) } } 序列化map func main12() { bytes, err := json.Marshal(mMap) if err != nil { fmt.Println(\"序列化失败,err=\", err) } else { jsonStr := string(bytes) fmt.Println(\"序列化结果：\", jsonStr) } } 序列化切片 func main13() { bytes, err := json.Marshal(mSlice) if err != nil { fmt.Println(\"序列化失败,err=\", err) } else { jsonStr := string(bytes) fmt.Println(\"序列化结果：\", jsonStr) } } powered by Gitbook修订时间： 2020-04-28 10:18:03 "},"05JSONIO/JSON读写2-JSON反序列化.html":{"url":"05JSONIO/JSON读写2-JSON反序列化.html","title":"JSON反序列化","keywords":"","body":"JSON反序列化 导入依赖 import ( \"encoding/json\" \"fmt\" ) 定义结构体 type Human struct { Name string Age int Sex bool Hobbies []string } 定义数据 var jsonStr,jsonStr2 string var zqd Human var theMap map[string]interface{} var theSlice []map[string]interface{} 数据初始化 func init() { jsonStr = \"{\\\"age\\\":20,\\\"hobbies\\\":[\\\"质检\\\",\\\"维护流水线\\\",\\\"打饭\\\"],\\\"name\\\":\\\"张全蛋\\\",\\\"sex\\\":true}\" jsonStr2 = \"[{\\\"age\\\":20,\\\"hobbies\\\":[\\\"质检\\\",\\\"维护流水线\\\",\\\"打饭\\\"],\\\"name\\\":\\\"张全蛋\\\",\\\"sex\\\":true},{\\\"age\\\":23,\\\"hobbies\\\":[\\\"破坏\\\",\\\"维护流水线\\\",\\\"打人\\\"],\\\"name\\\":\\\"穆铁柱\\\",\\\"sex\\\":false}]\" } 反序列化为结构体 func main21() { err := json.Unmarshal([]byte(jsonStr), &zqd) if err!=nil{ fmt.Println(\"反序列化失败，err=\",err) }else { fmt.Printf(\"反序列化成功：%#v\\n\",zqd) } } 反序列化为map func main22() { err := json.Unmarshal([]byte(jsonStr), &theMap) if err!=nil{ fmt.Println(\"反序列化失败，err=\",err) }else { fmt.Printf(\"反序列化成功：%#v\\n\", theMap) } } 反序列化为切片 func main23() { err := json.Unmarshal([]byte(jsonStr2), &theSlice) if err!=nil{ fmt.Println(\"反序列化失败，err=\",err) }else { fmt.Printf(\"反序列化成功：%v\\n\", theSlice) } } powered by Gitbook修订时间： 2020-04-28 10:18:03 "},"05JSONIO/JSON读写3-读写JSON文件.html":{"url":"05JSONIO/JSON读写3-读写JSON文件.html","title":"读写JSON文件","keywords":"","body":"读写JSON文件 概述 本地文件是存储JSOP数据的一个重要方案 将Go数据以JSON字符串的形式写出到文件中的过程称之为编码 从文件中读取JSON字符串为Go数据的过程称之为解码 导入依赖 import ( \"encoding/json\" \"os\" \"fmt\" ) 定义结构体 type PersonII struct { Name string Age int Sex bool Hobbies []string } 将Go数据编码到json文件 将结构体实例以JSON格式写出到文件的过程称为编码，其一般步骤是： 准备Go数据 打开文件并创建基于该文件的JSON编码器 将Go数据编码到文件中 func main31() { //创建PersonII实例小黑子 xhz := PersonII{\"小黑子\", 60, true, []string{\"撸代码\", \"撸项目\", \"撸其它的\"}} //创建文件（并打开） filePtr, err := os.Create(\"d:/小黑子.json\") if err!=nil{ fmt.Println(\"创建文件失败，err=\",err) return } defer filePtr.Close() //创建基于文件的JSON编码器 encoder := json.NewEncoder(filePtr) //将小黑子实例编码到文件中 err = encoder.Encode(xhz) if err!=nil{ fmt.Println(\"编码失败，err=\",err) }else{ fmt.Println(\"编码成功\") } } 将json文件解码为Go数据 从文件中读取JSON数据为Go语言数据的过程称之为解码，其一般步骤为： 打开含有JSON字符串的文件 创建基于改文件的JSON解码器 解码文件中的JSON数据到相应的Go数据指针中 func main32() { //预定义解码结果 var xhz PersonII //打开文件 filePtr, _ := os.Open(\"d:/小黑子.avi\") defer filePtr.Close() //创建该文件的json解码器 decoder := json.NewDecoder(filePtr) //把解码的结果存在xhz的地址中 err := decoder.Decode(&xhz) if err!=nil{ fmt.Println(\"解码失败，err=\",err) }else { fmt.Printf(\"解码成功:%#v\\n\",xhz) } } powered by Gitbook修订时间： 2020-04-28 10:18:03 "},"06Exception/异常处理1-恐慌与处理.html":{"url":"06Exception/异常处理1-恐慌与处理.html","title":"恐慌与处理","keywords":"","body":"恐慌与处理 恐慌概述 代码在运行时如果出现异常，系统会报出恐慌（panic）并终止运行 IDE和终端打印的恐慌日志，包含了恐慌的信息以及报恐慌所在的代码行 恐慌好比一种震撼的暴力教育，其目的在于警示开发者，什么是可以的而什么又是不可以的 代码在交付使用前要经过充分测试，处理一切可能的恐慌 系统报恐慌 本例中由于我们错误地使用了一个超出数组长度的下标，导致系统报出恐慌 func demo21() { a := [5]int{0, 1, 2, 3, 4} a[1] = 123 index := 2 + 8 //系统报恐慌：运行时错误（exe在执行的过程中发生的错误），下标越界 //panic: runtime error: index out of range a[index] = 123 } 自己报恐慌 除了系统报出恐慌以外，我们还可以通过内建函数panic自己报出恐慌 自己报恐慌的目的，是预测程序在运行时可能出现的异常情形，并提示当前代码的调用者以错误信息 下面的例子中，计算圆面积这一函数在调用时如果传入了一个负数的半径，则会报出恐慌，提示半径是不可以为负数的，这样做相当于强制代码的调用者传入非负的半径 func getCircleArea(radius float32) (area float32) { //如果半径参数为负数，则抛出异常 if radius 处理恐慌 程序在上线前必须测试和扫灭所有可能的恐慌 在没有对恐慌进行任何处理前，程序会在报恐慌的行崩溃 Go语言提供了recover內建函数，让崩溃的程序复活并返回造成程序崩溃的error实例 所以我们可以在正式的业务逻辑开始前，事先挂起一个延时处理恐慌的函数，在其中借助recover函数获得造成程序崩溃的error并处理 当程序在123行崩溃时，123行以后的代码就不会再执行了，而是直接跳转到defer了的恐慌处理程序 func demo23() { //延时执行恐慌处理程序 //延时到什么时候？①函数正常结束前②恐慌发生时（函数内恐慌以后的代码将不会执行） defer func() { if err := recover(); err != nil { fmt.Println(err) } }() //下面的函数会恐慌(报恐慌) getCircleArea(-5) //所以这里执行不到，而是直接跳到defer所定义的恐慌处理程序 print(\"这里有美女相赠\") } 下面这段代码对前面的demo23进行了调用 由于demo23()是一个已经定义了恐慌处理方式的函数，程序不会因为demo23中的恐慌而崩溃 func demo24() { //本来该应该因恐慌而死，但已经在其中插入了异常(恐慌)处理程序，就不会造成程序崩溃 //丢失的部分仅仅为demo23中恐慌以后的部分 demo23() fmt.Println(\"抢钱抢粮抢地盘\") fmt.Println(\"GAME OVER\") } powered by Gitbook修订时间： 2020-04-28 10:18:03 "},"06Exception/异常处理2-以返回错误替代恐慌.html":{"url":"06Exception/异常处理2-以返回错误替代恐慌.html","title":"以返回错误替代恐慌","keywords":"","body":"以返回错误替代恐慌 概述 通过恐慌报错的方式虽然直白有效，但动不动就崩溃显得有些暴力 Go语言还给我们提供了一种相对温和但同样有效的异常解决方案，那就是同时返回结果和错误（error实例） 如果结果正确时错误为空，如果错误不为空时结果为空（或没有业务意义的默认值） 这种方式显得温和而辩证，兼容性好，也不会造成程序崩溃 至于究竟是严厉好还是温和兼容好，开发者们可以见仁见智 下面实例中的圆面积计算函数中： 如果调用者传入了一个负数半径，程序也不会panic，但是会返回一个提示错误的error实例，此时结果是毫无意义的默认值0 如果调用者传入了合法的半径，则返回正确结果和一个为空的error实例 package main import ( \"errors\" \"fmt\" ) func main() { //获得调用的结果 ret, err := getCircleAreaII(5) //如果返回的错误不为空，则说明程序出现了异常 if err!=nil{ fmt.Println(err) }else { fmt.Println(\"ret=\",ret) } } /* 如果发生异常时，以返回错误的方式代替恐慌 正确结果和错误，必有一个为空 这样相对温和，也不会造成程序崩溃 */ func getCircleAreaII(radius float32)(ret float32,err error) { if radius powered by Gitbook修订时间： 2020-04-28 10:18:03 "},"06Exception/异常处理3-自定义异常.html":{"url":"06Exception/异常处理3-自定义异常.html","title":"自定义异常","keywords":"","body":"自定义异常 自定义异常概述 系统提供的异常类error无所不包但控制的粒度很粗糙 如果想要进行很精细化的报错和处理错误，就需要用到自定义异常 我们只要实现error接口中的Error() string方法，就可以自定义异常了 自定义的异常与系统异常无二，同样可以panic，同样可以辩证互斥地返回【结果错误对】 自定义异常 下面的例子定义了一个【非法参数异常】 在这个自定义的结构体中，封装了异常提示信息、发生时间、造成异常的用户三个属性 这样的异常在报出和处理时，无疑具有更直观更丰富的参考价值 //自定义【非法参数异常】，封装异常提示信息、发生时间、造成异常的用户三个属性 type InvalidArgError struct { info string when time.Time user string } //实现系统的异常接口 func (iae *InvalidArgError)Error() string{ return fmt.Sprintln(iae.info,iae.when,iae.user) } //模仿SDK，提供一个创建异常对象的工厂方法，自动记录发生异常的时间和用户 func NewInvalidArgError(info string) *InvalidArgError { iaePtr := new(InvalidArgError) iaePtr.info = info iaePtr.when = time.Now() iaePtr.user = \"bill\" return iaePtr } 以错误的形式返回异常信息 //如果参数为负数时，返回一个自定义的异常 func getCircleAreaIII(radius float32)(ret float32,err interface{}) { if radius 以恐慌的形式报异常并处理 //半径为负数的情况下以恐慌形式报出异常 func getCircleAreaIV(radius float32)(ret float32) { if radius powered by Gitbook修订时间： 2020-04-28 10:18:03 "},"07GoReflect/反射概念.html":{"url":"07GoReflect/反射概念.html","title":"概念","keywords":"","body":"概念 什么是反射 常规的代码逻辑是：先写好剧本，再照着剧本演； 即：将要使用一个什么类型的对象（“演员”），然后访问和设置其什么属性，调用其什么方法，都是预先想好的； 这一切的前提是：你必须预先知道对象的类型！ 而反射则提供了完全不同的方式； 对于运行时内存中的任何一个对象，你不需要预先知道其类型是什么，也能访问其全部属性，调用其全部方法； 即反射支持【运行时的动态类型检测】； 这极大地提高了代码的灵活性，使得我们可以在代码时去动态操作一些不可以预知的未来； 反射的主要作用在于编写通用的框架； 框架的要求就是：不管你来的是什么类型，我都支持你——这就需要用到【运行时的动态类型检测】，即反射； 反射功能一览 当我们在运行时动态捕获一个实例，我们可以： 获得检测其类型和值 获得其所有属性的类型和名值 获得其所有方法的类型和名值 访问其任意属性 调用其任意方法 反射应用场景举例：导出商品列表到Excel 需求是：不管用户在界面上看到什么商品列表，当它捅一下导出按钮，就将该商品的所有属性和值写出为文件； 本例的难点是：我们无法预知用户会选择导出什么类型的商品数据、它有哪些属性，也就无法相应地去创建Excel数据表的列； 因为商品的种类太多，如果用“正射”去做，那么有多少商品类型我们就要写多少个switch或if分支，然后在每一个分支里根据当前分支的具体商品类型去构造相应的数据列，这显然是狠蹩脚、狠难维护和扩展的； 而通过反射来做就易如反掌了，管你用户要导出的是什么商品实例，我可以动态地解析其类型、动态获知其所有属性和方法，然后根据再根据其具体属性名称去创建相应的表格列，并将属性值填入其中； 接下来我们通过在运行时捕获一个Human的实例（我事先并不知道类型），来说明反射的功能； 定义结构体 这里我们为Human设置了2个属性+3个方法 type Human struct { Name string \"姓名\" Age int \"年龄\" } func (h *Human) GetName() string { fmt.Println(\"GetName called\",h.Name) return h.Name } func (h *Human) SetName(name string) { fmt.Println(\"SetName called:\", name) h.Name = name } func (h *Human) Eat(food string, grams int) (power int) { fmt.Println(\"Eat called:\", food, grams) return 5 * grams } 然后假设我们在程序运行时，捕获到一个Human实例，在事先根本不知情的情况下，让我们把这个实例的老底扒个底朝天吧： func main() { //创建对象（在实际代码运行中可以是任意未知类型） h := Human{\"bill\", 60} //获取任意对象的类型和值 getObjTypeValue(h) //获得任意对象的所有属性 getObjFields(h) //获取任意对象的所有方法 getObjMethods(&h) //修改对象任意属性的值 modifyFieldValue(&h) //动态调用对象的任意方法 callMethods(&h) fmt.Println(\"after:h=\", h) } 获取任意对象的类型和值 func getObjTypeValue(obj interface{}) { oType := reflect.TypeOf(obj) oKind := oType.Kind() fmt.Println(oType, oKind) oValue := reflect.ValueOf(obj) fmt.Println(oValue) } 获得任意对象的所有属性 func getObjFields(obj interface{}) { oType := reflect.TypeOf(obj) oValue := reflect.ValueOf(obj) fieldsCount := oType.NumField() for i := 0; i 获取任意对象的所有方法 func getObjMethods(obj interface{}) { oType := reflect.TypeOf(obj) fmt.Println(oType.NumMethod()) for i := 0; i 修改对象任意属性的值 func modifyFieldValue(objPtr interface{}) { //得到【指针的Value】 oPtrValue := reflect.ValueOf(objPtr) //得到【指针所指向的值（结构体）的Value】 oValue := oPtrValue.Elem() fmt.Println(oValue) //遍历所有属性的值 for i := 0; i 动态调用对象的任意方法 func callMethods(objPtr interface{}) { //要通过对象的oType拿取方法的参数列表(oType.In(i)) oType := reflect.TypeOf(objPtr) //要通过对象的oValue拿取方法的具体实现(methodValue) oValue := reflect.ValueOf(objPtr) //根据方法的数量进行遍历 for i := 0; i powered by Gitbook修订时间： 2020-05-07 19:10:53 "},"08GoTest/单元测试.html":{"url":"08GoTest/单元测试.html","title":"单元测试","keywords":"","body":"单元测试 单元测试代码标准 单元测试文件需要遵循以下原则： 文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码 必须import testing这个包 所有的测试用例函数必须是Test开头 测试用例会按照源代码中写的顺序依次执行 测试函数TestXxx()的参数是testing.T，我们可以使用该类型来记录错误或者是测试状态 测试格式：func TestXxx (t *testing.T),Xxx部分可以为任意的字母数字的组合，但是首字母不能是小写字母[a-z]，例如Testintdiv是错误的函数名。 函数中通过调用testing.T的Error, Errorf, FailNow, Fatal,FatalIf方法，说明测试不通过，调用Log方法用来记录测试的信息。 定义工具函数 文件存在于main包下的mathutil.go中 func Add(a, b int) int { return a + b } func Mul(a, b int) int { return a * b } 定义测试用例 文件存在于main包下的mathutil_test.go中 package main import \"testing\" func TestAdd(t *testing.T) { ret :=Add(3,2) if ret!=5{ t.Errorf(\"期望是%d，实际得到%d\",5,ret) return } t.Log(\"TestAdd测试通过\") } func TestMul(t *testing.T) { ret :=Mul(3,2) if ret!=5{ t.Errorf(\"期望是%d，实际得到%d\",5,ret) return } t.Log(\"TestMul测试通过\") } 运行测试用例 有两种方式运行测试用例： GoLandIDE中选中测试用例所在的包，右键选择Run->go test xxx 终端cd到测试用例所在的包，执行下面的命令： go test -v ./ 定义待测试的结构体 文件存在于main包下的models.go中 测试结构体中的函数 文件存在于main包下的model_test.go中 powered by Gitbook修订时间： 2020-05-08 12:04:36 "}}